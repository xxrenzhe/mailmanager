<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é‚®ä»¶éªŒè¯ç ç®¡ç†ç³»ç»Ÿ - æµè§ˆå™¨ç‰ˆ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: white;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 28px;
            margin-bottom: 20px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: #f8f9fa;
            border-radius: 20px;
            font-size: 14px;
        }

        .stat-number {
            font-weight: bold;
            color: #007bff;
        }

        .header-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,123,255,0.3);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #1e7e34;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 25px;
        }

        .table-container {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .table-header {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .table-title {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
        }

        .table-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-input {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            width: 300px;
            max-width: 100%;
        }

        .filter-select {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            background: white;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            background: #e9ecef;
        }

        .sort-icon {
            margin-left: 8px;
            opacity: 0.5;
        }

        .sort-icon.active {
            opacity: 1;
            color: #007bff;
        }

        tbody tr {
            transition: background 0.2s;
        }

        tbody tr:hover {
            background: #f8f9fa;
        }

        .checkbox-cell {
            width: 50px;
        }

        .custom-checkbox {
            position: relative;
            display: inline-block;
            width: 20px;
            height: 20px;
        }

        .custom-checkbox input {
            opacity: 0;
            position: absolute;
            cursor: pointer;
        }

        .checkmark {
            position: absolute;
            top: 0;
            left: 0;
            height: 20px;
            width: 20px;
            background-color: #eee;
            border: 2px solid #ccc;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .custom-checkbox input:checked ~ .checkmark {
            background-color: #007bff;
            border-color: #007bff;
        }

        .checkmark:after {
            content: "";
            position: absolute;
            display: none;
            left: 6px;
            top: 2px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        .custom-checkbox input:checked ~ .checkmark:after {
            display: block;
        }

        .status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-authorized {
            background: #d4edda;
            color: #155724;
        }

        .status-authorized .status-dot {
            background: #28a745;
        }

        .status-pending {
            background: #fff3cd;
            color: #856404;
        }

        .status-pending .status-dot {
            background: #ffc107;
        }

        .status-reauth_needed {
            background: #f8d7da;
            color: #721c24;
        }

        .status-reauth_needed .status-dot {
            background: #dc3545;
        }

        .email-cell {
            max-width: 250px;
        }

        .email-primary {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
        }

        .email-secondary {
            font-size: 12px;
            color: #6c757d;
        }

        .code-display {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 16px;
            font-weight: bold;
            color: #007bff;
            background: #e3f2fd;
            padding: 8px 12px;
            border-radius: 6px;
            border: 2px solid #007bff;
            letter-spacing: 1px;
        }

        .code-display.empty {
            color: #6c757d;
            background: #f8f9fa;
            border-color: #dee2e6;
            font-style: italic;
        }

        .time-display {
            font-size: 13px;
            color: #6c757d;
        }

        .actions {
            display: flex;
            gap: 8px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        tbody tr:hover .actions {
            opacity: 1;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 6px;
        }

        .pagination {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #dee2e6;
        }

        .pagination-info {
            color: #6c757d;
            font-size: 14px;
        }

        .pagination-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
        }

        .modal-content {
            position: relative;
            background-color: white;
            margin: 50px auto;
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            padding: 25px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
        }

        .modal-close {
            font-size: 28px;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .modal-close:hover {
            color: #000;
            background: #f8f9fa;
        }

        .modal-body {
            padding: 25px;
        }

        .modal-footer {
            padding: 20px 25px;
            border-top: 1px solid #dee2e6;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #495057;
        }

        .form-input {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ced4da;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .form-input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
        }

        .form-help {
            margin-top: 6px;
            font-size: 12px;
            color: #6c757d;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #0056b3);
            width: 0%;
            transition: width 0.3s ease;
        }

        .storage-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 100;
        }

        .storage-icon {
            font-size: 20px;
        }

        .storage-info {
            font-size: 12px;
            color: #6c757d;
        }

        .storage-bar {
            width: 120px;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
        }

        .storage-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #007bff);
            transition: width 0.3s ease;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            margin-bottom: 10px;
            color: #495057;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-radius: 50%;
            border-top: 2px solid #007bff;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            z-index: 2000;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 300px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            animation: slideInRight 0.3s ease;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast.success { background: #28a745; }
        .toast.error { background: #dc3545; }
        .toast.warning { background: #ffc107; color: #212529; }
        .toast.info { background: #17a2b8; }

        .bulk-import-section {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .bulk-import-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .bulk-import-steps {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .step-item {
            display: flex;
            align-items: start;
            gap: 15px;
            margin-bottom: 15px;
        }

        .step-item:last-child {
            margin-bottom: 0;
        }

        .step-number {
            width: 24px;
            height: 24px;
            background: #007bff;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .step-content {
            flex: 1;
        }

        .step-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: #2c3e50;
        }

        .step-description {
            font-size: 14px;
            color: #6c757d;
            line-height: 1.5;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header-buttons {
                flex-direction: column;
            }

            .table-header {
                flex-direction: column;
                align-items: stretch;
            }

            .search-input {
                width: 100%;
            }

            .table-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .modal-content {
                margin: 10px;
                width: calc(100% - 20px);
            }

            .storage-indicator {
                bottom: 10px;
                right: 10px;
                left: 10px;
            }

            .actions {
                opacity: 1;
            }

            table {
                font-size: 14px;
            }

            th, td {
                padding: 10px;
            }

            .email-cell {
                max-width: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>
                <span>ğŸ“§</span>
                <span>é‚®ä»¶éªŒè¯ç ç®¡ç†ç³»ç»Ÿ - æµè§ˆå™¨ç‰ˆ</span>
            </h1>

            <div class="header-stats">
                <div class="stat-item">
                    <span>æ€»è´¦æˆ·:</span>
                    <span class="stat-number" id="totalAccounts">0</span>
                </div>
                <div class="stat-item">
                    <span>å·²æˆæƒ:</span>
                    <span class="stat-number" id="authorizedAccounts">0</span>
                </div>
                <div class="stat-item">
                    <span>å¾…æˆæƒ:</span>
                    <span class="stat-number" id="pendingAccounts">0</span>
                </div>
                <div class="stat-item">
                    <span>éœ€é‡æ–°æˆæƒ:</span>
                    <span class="stat-number" id="reauthAccounts">0</span>
                </div>
                <div class="stat-item">
                    <span>éªŒè¯ç :</span>
                    <span class="stat-number" id="totalCodes">0</span>
                </div>
            </div>

            <div class="header-buttons">
                <button class="btn-primary" onclick="openAddAccountModal()">
                    <span>â•</span>
                    <span>æ·»åŠ è´¦æˆ·</span>
                </button>
                <button class="btn-success" onclick="openBulkImportModal()">
                    <span>ğŸ“¥</span>
                    <span>æ‰¹é‡å¯¼å…¥</span>
                </button>
                <button class="btn-secondary" onclick="exportData()">
                    <span>ğŸ“¤</span>
                    <span>å¯¼å‡ºæ•°æ®</span>
                </button>
                <button class="btn-warning" onclick="bulkSync()">
                    <span>ğŸ”„</span>
                    <span>æ‰¹é‡åŒæ­¥</span>
                </button>
                <button class="btn-secondary" onclick="refreshData()">
                    <span>ğŸ”ƒ</span>
                    <span>åˆ·æ–°</span>
                </button>
            </div>
        </header>

        <div class="bulk-import-section" id="bulkImportSection" style="display: none;">
            <div class="bulk-import-header">
                <h3>æ‰¹é‡å¯¼å…¥é‚®ç®±è´¦æˆ·</h3>
                <button class="btn-secondary" onclick="closeBulkImport()">âœ•</button>
            </div>

            <div class="bulk-import-steps">
                <div class="step-item">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <div class="step-title">å‡†å¤‡è´¦æˆ·æ•°æ®</div>
                        <div class="step-description">
                            åˆ›å»ºCSVæ–‡ä»¶ï¼Œæ ¼å¼ï¼š<br>
                            <code style="background: #f8f9fa; padding: 2px 6px; border-radius: 3px;">é‚®ç®±åœ°å€,Client ID,Refresh Token</code><br>
                            æ¯è¡Œä¸€ä¸ªè´¦æˆ·ï¼Œæ”¯æŒExcelæˆ–æ–‡æœ¬ç¼–è¾‘å™¨ç¼–è¾‘
                        </div>
                    </div>
                </div>
                <div class="step-item">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <div class="step-title">ä¸Šä¼ æ–‡ä»¶</div>
                        <div class="step-description">
                            é€‰æ‹©å‡†å¤‡å¥½çš„CSVæ–‡ä»¶ï¼Œç³»ç»Ÿå°†è‡ªåŠ¨è§£æå¹¶æ˜¾ç¤ºé¢„è§ˆ
                        </div>
                    </div>
                </div>
                <div class="step-item">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <div class="step-title">ç¡®è®¤å¯¼å…¥</div>
                        <div class="step-description">
                            ç¡®è®¤è´¦æˆ·æ•°æ®æ— è¯¯åï¼Œç³»ç»Ÿå°†è‡ªåŠ¨å¼€å§‹å¯¼å…¥å’ŒéªŒè¯æµç¨‹
                        </div>
                    </div>
                </div>
            </div>

            <div style="display: flex; gap: 15px; align-items: center;">
                <input type="file" id="bulkImportFile" accept=".txt,.csv" style="display: none;">
                <button class="btn-primary" onclick="document.getElementById('bulkImportFile').click()">
                    <span>ğŸ“</span>
                    <span>é€‰æ‹©æ–‡ä»¶</span>
                </button>
                <span id="selectedFileName" style="color: #6c757d;">æœªé€‰æ‹©æ–‡ä»¶</span>
                <button class="btn-success" id="startBulkImport" onclick="startBulkImport()" disabled>
                    <span>ğŸš€</span>
                    <span>å¼€å§‹å¯¼å…¥</span>
                </button>
            </div>

            <div id="bulkImportPreview" style="margin-top: 20px; display: none;">
                <h4>é¢„è§ˆ (å‰10ä¸ªé‚®ç®±):</h4>
                <div id="previewList" style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 10px;"></div>
            </div>

            <div id="bulkImportProgress" style="display: none; margin-top: 20px;">
                <h4>å¯¼å…¥è¿›åº¦:</h4>
                <div class="progress-bar">
                    <div class="progress-fill" id="importProgressFill"></div>
                </div>
                <div id="importStatusText">å‡†å¤‡ä¸­...</div>
            </div>
        </div>

        <div class="main-content">
            <div class="table-container">
                <div class="table-header">
                    <h2 class="table-title">è´¦æˆ·åˆ—è¡¨</h2>
                    <div class="table-controls">
                        <input type="text" class="search-input" placeholder="ğŸ” æœç´¢é‚®ç®±åœ°å€..." oninput="searchAccounts(this.value)">
                        <select class="filter-select" onchange="filterByStatus(this.value)">
                            <option value="">æ‰€æœ‰çŠ¶æ€</option>
                            <option value="authorized">å·²æˆæƒ</option>
                            <option value="pending">å¾…æˆæƒ</option>
                            <option value="reauth_needed">éœ€é‡æ–°æˆæƒ</option>
                        </select>
                    </div>
                </div>

                <div style="overflow-x: auto;">
                    <table>
                        <thead>
                            <tr>
                                <th class="checkbox-cell">
                                    <label class="custom-checkbox">
                                        <input type="checkbox" id="selectAll" onchange="toggleSelectAll()">
                                        <span class="checkmark"></span>
                                    </label>
                                </th>
                                <th onclick="sortTable('status')">
                                    çŠ¶æ€
                                    <span class="sort-icon" id="sort-status">â†•</span>
                                </th>
                                <th onclick="sortTable('email')">
                                    é‚®ç®±åœ°å€
                                    <span class="sort-icon" id="sort-email">â†•</span>
                                </th>
                                <th onclick="sortTable('code')">
                                    æœ€æ–°éªŒè¯ç 
                                    <span class="sort-icon" id="sort-code">â†•</span>
                                </th>
                                <th onclick="sortTable('received_time')">
                                    æ”¶ä»¶æ—¶é—´
                                    <span class="sort-icon" id="sort-received_time">â†•</span>
                                </th>
                                <th onclick="sortTable('updated_time')">
                                    æ›´æ–°æ—¶é—´
                                    <span class="sort-icon" id="sort-updated_time">â†•</span>
                                </th>
                                <th>æ“ä½œ</th>
                            </tr>
                        </thead>
                        <tbody id="accountsTableBody">
                            <!-- åŠ¨æ€ç”Ÿæˆ -->
                        </tbody>
                    </table>
                </div>

                <div class="pagination">
                    <div class="pagination-info">
                        <span id="paginationInfo">æ˜¾ç¤º 0 ä¸ªè´¦æˆ·</span>
                    </div>
                    <div class="pagination-controls">
                        <button class="btn-secondary btn-sm" id="prevPage" onclick="changePage(-1)" disabled>
                            ä¸Šä¸€é¡µ
                        </button>
                        <span id="pageInfo">ç¬¬ 1 é¡µï¼Œå…± 1 é¡µ</span>
                        <button class="btn-secondary btn-sm" id="nextPage" onclick="changePage(1)" disabled>
                            ä¸‹ä¸€é¡µ
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- æ·»åŠ è´¦æˆ·æ¨¡æ€æ¡† -->
    <div id="addAccountModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">æ·»åŠ é‚®ç®±è´¦æˆ·</h2>
                <button class="modal-close" onclick="closeModal('addAccountModal')">&times;</button>
            </div>
            <div class="modal-body">
                <form id="addAccountForm" onsubmit="addAccount(event)">
                    <div class="form-group">
                        <label class="form-label">é‚®ç®±åœ°å€ *</label>
                        <input type="email" class="form-input" id="newAccountEmail" required placeholder="example@outlook.com">
                        <div class="form-help">è¯·è¾“å…¥å®Œæ•´çš„é‚®ç®±åœ°å€</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">æ˜¾ç¤ºåç§°</label>
                        <input type="text" class="form-input" id="newAccountName" placeholder="å¯é€‰ï¼Œç”¨äºè¯†åˆ«è´¦æˆ·">
                        <div class="form-help">ä¸ºè´¦æˆ·è®¾ç½®å‹å¥½çš„æ˜¾ç¤ºåç§°</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Client ID *</label>
                        <input type="text" class="form-input" id="newAccountClientId" required placeholder="Azureåº”ç”¨å®¢æˆ·ç«¯ID">
                        <div class="form-help">ä»Azureåº”ç”¨æ³¨å†Œè·å–çš„å®¢æˆ·ç«¯ID</div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Refresh Token *</label>
                        <textarea class="form-input" id="newAccountRefreshToken" required placeholder="Microsoftè´¦æˆ·çš„åˆ·æ–°ä»¤ç‰Œ" rows="3"></textarea>
                        <div class="form-help">ç”¨äºè‡ªåŠ¨è·å–è®¿é—®ä»¤ç‰Œçš„åˆ·æ–°ä»¤ç‰Œ</div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeModal('addAccountModal')">å–æ¶ˆ</button>
                <button class="btn-primary" onclick="document.getElementById('addAccountForm').requestSubmit()">
                    <span>â•</span>
                    <span>æ·»åŠ è´¦æˆ·</span>
                </button>
            </div>
        </div>
    </div>

  
    <!-- å­˜å‚¨æŒ‡ç¤ºå™¨ -->
    <div class="storage-indicator">
        <span class="storage-icon">ğŸ’¾</span>
        <div>
            <div class="storage-info">æœ¬åœ°å­˜å‚¨</div>
            <div class="storage-bar">
                <div class="storage-fill" id="storageFill"></div>
            </div>
        </div>
        <div class="storage-info" id="storageText">0 KB</div>
    </div>

    <script>
        // å®Œæ•´åŠŸèƒ½çš„é‚®ä»¶ç®¡ç†ç³»ç»Ÿ - æµè§ˆå™¨ç‰ˆæœ¬
        class BrowserMailManager {
            constructor() {
                this.accounts = [];
                this.filteredAccounts = [];
                this.selectedAccounts = new Set();
                this.currentPage = 1;
                this.itemsPerPage = 20;
                this.sortField = 'updated_time';
                this.sortDirection = 'desc';
                this.searchQuery = '';
                this.statusFilter = '';

                // ä»£ç†æœåŠ¡å™¨é…ç½®
                this.proxyConfig = {
                    baseUrl: window.location.protocol === 'file:' ?
                        'http://localhost:3001' :
                        window.location.origin.replace(':8000', ':3001'),
                    tokenEndpoint: '/api/microsoft/token',
                    outlookEndpoint: '/api/outlook'
                };

                // æ£€æµ‹ä»£ç†æœåŠ¡å™¨å¯ç”¨æ€§
                this.checkProxyServer();

                this.init();
            }

            async init() {
                await this.loadAccounts();
                this.setupEventListeners();
                this.render();
                this.updateStats();
                this.updateStorageIndicator();
                this.startPeriodicSync();

                // æ£€æŸ¥ä»£ç†æœåŠ¡å™¨
                await this.checkProxyServer();

                console.log('é‚®ä»¶ç®¡ç†ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
            }

            // æ£€æŸ¥ä»£ç†æœåŠ¡å™¨
            async checkProxyServer() {
                try {
                    const response = await fetch(`${this.proxyConfig.baseUrl}/api/health`);
                    if (response.ok) {
                        console.log('âœ… ä»£ç†æœåŠ¡å™¨è¿æ¥æ­£å¸¸');
                        this.proxyAvailable = true;
                    } else {
                        throw new Error('ä»£ç†æœåŠ¡å™¨å“åº”å¼‚å¸¸');
                    }
                } catch (error) {
                    console.warn('âš ï¸ ä»£ç†æœåŠ¡å™¨ä¸å¯ç”¨ï¼Œå°†å°è¯•ç›´æ¥è®¿é—®API:', error.message);
                    this.proxyAvailable = false;
                }
            }

            setupEventListeners() {
                // æ–‡ä»¶ä¸Šä¼ ç›‘å¬
                document.getElementById('bulkImportFile').addEventListener('change', (e) => {
                    this.handleBulkImportFile(e);
                });

                // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
                window.addEventListener('click', (e) => {
                    if (e.target.classList.contains('modal')) {
                        e.target.style.display = 'none';
                    }
                });

                // é”®ç›˜å¿«æ·é”®
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        document.querySelectorAll('.modal').forEach(modal => {
                            modal.style.display = 'none';
                        });
                    }
                    if (e.ctrlKey && e.key === 'n') {
                        e.preventDefault();
                        openAddAccountModal();
                    }
                });
            }

            // æ•°æ®å­˜å‚¨ - ä½¿ç”¨IndexedDBä»¥æ”¯æŒå¤§é‡æ•°æ®
            async saveAccounts() {
                try {
                    const data = {
                        accounts: this.accounts,
                        version: '2.0',
                        lastUpdated: new Date().toISOString()
                    };

                    // ä½¿ç”¨IndexedDBå­˜å‚¨å¤§é‡æ•°æ®
                    if ('indexedDB' in window) {
                        await this.saveToIndexedDB(data);
                    } else {
                        // é™çº§åˆ°LocalStorage
                        localStorage.setItem('mailmanager_data', JSON.stringify(data));
                    }
                } catch (error) {
                    console.error('ä¿å­˜æ•°æ®å¤±è´¥:', error);
                    this.showToast('æ•°æ®ä¿å­˜å¤±è´¥', 'error');
                }
            }

            async loadAccounts() {
                try {
                    let data;

                    if ('indexedDB' in window) {
                        data = await this.loadFromIndexedDB();
                    } else {
                        // é™çº§åˆ°LocalStorage
                        const stored = localStorage.getItem('mailmanager_data');
                        data = stored ? JSON.parse(stored) : null;
                    }

                    this.accounts = data?.accounts || [];
                    this.filteredAccounts = [...this.accounts];
                } catch (error) {
                    console.error('åŠ è½½æ•°æ®å¤±è´¥:', error);
                    this.accounts = [];
                    this.filteredAccounts = [];
                }
            }

            async saveToIndexedDB(data) {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('MailManagerDB', 1);

                    request.onerror = () => reject(request.error);

                    request.onsuccess = () => {
                        const db = request.result;
                        const transaction = db.transaction(['accounts'], 'readwrite');
                        const store = transaction.objectStore('accounts');

                        const putRequest = store.put(data, 'main_data');
                        putRequest.onsuccess = () => resolve();
                        putRequest.onerror = () => reject(putRequest.error);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('accounts')) {
                            db.createObjectStore('accounts');
                        }
                    };
                });
            }

            async loadFromIndexedDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('MailManagerDB', 1);

                    request.onerror = () => reject(request.error);

                    request.onsuccess = () => {
                        const db = request.result;
                        const transaction = db.transaction(['accounts'], 'readonly');
                        const store = transaction.objectStore('accounts');

                        const getRequest = store.get('main_data');
                        getRequest.onsuccess = () => resolve(getRequest.result);
                        getRequest.onerror = () => reject(getRequest.error);
                    };

                    request.onupgradeneeded = () => {
                        resolve(null);
                    };
                });
            }

            // è´¦æˆ·ç®¡ç†
            addAccount(email, name, clientId, refreshToken) {
                if (this.accounts.some(acc => acc.email === email)) {
                    throw new Error('è¯¥é‚®ç®±åœ°å€å·²å­˜åœ¨');
                }

                const account = {
                    id: Date.now().toString(),
                    email: email,
                    name: name || email,
                    client_id: clientId,
                    refresh_token: refreshToken,
                    status: 'pending',
                    codes: [],
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                    access_token: null,
                    token_expires_at: null,
                    last_sync: null
                };

                this.accounts.push(account);
                this.saveAccounts();
                return account;
            }

            deleteAccount(id) {
                this.accounts = this.accounts.filter(acc => acc.id !== id);
                this.selectedAccounts.delete(id);
                this.saveAccounts();
            }

            updateAccountStatus(id, status, tokens = {}) {
                const account = this.accounts.find(acc => acc.id === id);
                if (account) {
                    account.status = status;
                    account.updated_at = new Date().toISOString();

                    if (tokens.access_token) {
                        account.access_token = tokens.access_token;
                        account.refresh_token = tokens.refresh_token;
                        account.token_expires_at = tokens.expires_at;
                    }

                    this.saveAccounts();
                }
            }

            addVerificationCode(accountId, code, sender, receivedAt) {
                const account = this.accounts.find(acc => acc.id === accountId);
                if (account) {
                    const newCode = {
                        code: code,
                        sender: sender || 'Unknown',
                        received_at: receivedAt || new Date().toISOString(),
                        extracted_at: new Date().toISOString()
                    };

                    account.codes.unshift(newCode);

                    // åªä¿ç•™æœ€æ–°50ä¸ªéªŒè¯ç 
                    if (account.codes.length > 50) {
                        account.codes = account.codes.slice(0, 50);
                    }

                    account.updated_at = new Date().toISOString();
                    this.saveAccounts();
                }
            }

            // æœç´¢å’Œè¿‡æ»¤
            searchAccounts(query) {
                this.searchQuery = query.toLowerCase();
                this.applyFilters();
            }

            filterByStatus(status) {
                this.statusFilter = status;
                this.applyFilters();
            }

            applyFilters() {
                this.filteredAccounts = this.accounts.filter(account => {
                    const matchesSearch = !this.searchQuery ||
                        account.email.toLowerCase().includes(this.searchQuery) ||
                        account.name.toLowerCase().includes(this.searchQuery);

                    const matchesStatus = !this.statusFilter || account.status === this.statusFilter;

                    return matchesSearch && matchesStatus;
                });

                this.currentPage = 1;
                this.render();
            }

            // æ’åº
            sortTable(field) {
                if (this.sortField === field) {
                    this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    this.sortField = field;
                    this.sortDirection = 'asc';
                }

                // æ›´æ–°æ’åºå›¾æ ‡
                document.querySelectorAll('.sort-icon').forEach(icon => {
                    icon.classList.remove('active');
                    icon.textContent = 'â†•';
                });

                const currentIcon = document.getElementById(`sort-${field}`);
                currentIcon.classList.add('active');
                currentIcon.textContent = this.sortDirection === 'asc' ? 'â†‘' : 'â†“';

                this.applyFilters();
            }

            sortAccounts(accounts) {
                return accounts.sort((a, b) => {
                    let aValue, bValue;

                    switch (this.sortField) {
                        case 'status':
                            aValue = a.status;
                            bValue = b.status;
                            break;
                        case 'email':
                            aValue = a.email.toLowerCase();
                            bValue = b.email.toLowerCase();
                            break;
                        case 'code':
                            aValue = a.codes[0]?.code || '';
                            bValue = b.codes[0]?.code || '';
                            break;
                        case 'received_time':
                            aValue = a.codes[0]?.received_at || '';
                            bValue = b.codes[0]?.received_at || '';
                            break;
                        case 'updated_time':
                            aValue = a.updated_at;
                            bValue = b.updated_at;
                            break;
                        default:
                            return 0;
                    }

                    if (!aValue && !bValue) return 0;
                    if (!aValue) return 1;
                    if (!bValue) return -1;

                    let comparison = 0;
                    if (aValue > bValue) comparison = 1;
                    if (aValue < bValue) comparison = -1;

                    return this.sortDirection === 'desc' ? -comparison : comparison;
                });
            }

            // æ¸²æŸ“
            render() {
                this.renderTable();
                this.updatePagination();
            }

            renderTable() {
                const tbody = document.getElementById('accountsTableBody');

                if (this.filteredAccounts.length === 0) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="7" class="empty-state">
                                <div class="empty-state-icon">ğŸ“­</div>
                                <h3>æš‚æ— é‚®ç®±è´¦æˆ·</h3>
                                <p>ç‚¹å‡»"æ·»åŠ è´¦æˆ·"æˆ–"æ‰¹é‡å¯¼å…¥"å¼€å§‹ä½¿ç”¨</p>
                            </td>
                        </tr>
                    `;
                    return;
                }

                // æ’åº
                const sortedAccounts = this.sortAccounts([...this.filteredAccounts]);

                // åˆ†é¡µ
                const startIndex = (this.currentPage - 1) * this.itemsPerPage;
                const endIndex = startIndex + this.itemsPerPage;
                const pageAccounts = sortedAccounts.slice(startIndex, endIndex);

                tbody.innerHTML = pageAccounts.map(account => {
                    const latestCode = account.codes[0];
                    const isSelected = this.selectedAccounts.has(account.id);

                    return `
                        <tr>
                            <td class="checkbox-cell">
                                <label class="custom-checkbox">
                                    <input type="checkbox"
                                           class="account-checkbox"
                                           data-account-id="${account.id}"
                                           ${isSelected ? 'checked' : ''}
                                           onchange="toggleAccountSelection('${account.id}', this.checked)">
                                    <span class="checkmark"></span>
                                </label>
                            </td>
                            <td>
                                <span class="status-badge status-${account.status}">
                                    <span class="status-dot"></span>
                                    ${this.getStatusText(account.status)}
                                </span>
                            </td>
                            <td class="email-cell">
                                <div class="email-primary">${account.name}</div>
                                <div class="email-secondary">${account.email}</div>
                            </td>
                            <td>
                                ${latestCode ?
                                    `<div class="code-display">${latestCode.code}</div>` :
                                    '<div class="code-display empty">æš‚æ— éªŒè¯ç </div>'
                                }
                            </td>
                            <td>
                                <div class="time-display">
                                    ${latestCode ? this.formatTime(latestCode.received_at) : '---'}
                                </div>
                            </td>
                            <td>
                                <div class="time-display">
                                    ${this.formatTime(account.updated_at)}
                                </div>
                            </td>
                            <td>
                                <div class="actions">
                                    <button class="btn-sm btn-primary" onclick="syncAccount('${account.id}')" title="åŒæ­¥">
                                        ğŸ”„
                                    </button>
                                    <button class="btn-sm btn-warning" onclick="reauthAccount('${account.id}')" title="é‡æ–°æˆæƒ">
                                        ğŸ”
                                    </button>
                                    <button class="btn-sm btn-danger" onclick="deleteAccount('${account.id}')" title="åˆ é™¤">
                                        ğŸ—‘ï¸
                                    </button>
                                </div>
                            </td>
                        </tr>
                    `;
                }).join('');
            }

            updatePagination() {
                const totalItems = this.filteredAccounts.length;
                const totalPages = Math.ceil(totalItems / this.itemsPerPage);
                const startItem = totalItems === 0 ? 0 : (this.currentPage - 1) * this.itemsPerPage + 1;
                const endItem = Math.min(this.currentPage * this.itemsPerPage, totalItems);

                document.getElementById('paginationInfo').textContent =
                    `æ˜¾ç¤º ${startItem}-${endItem} ä¸ªè´¦æˆ·ï¼Œå…± ${totalItems} ä¸ª`;

                document.getElementById('pageInfo').textContent =
                    `ç¬¬ ${this.currentPage} é¡µï¼Œå…± ${totalPages || 1} é¡µ`;

                document.getElementById('prevPage').disabled = this.currentPage === 1;
                document.getElementById('nextPage').disabled = this.currentPage === totalPages || totalPages === 0;
            }

            updateStats() {
                const stats = {
                    total: this.accounts.length,
                    authorized: this.accounts.filter(acc => acc.status === 'authorized').length,
                    pending: this.accounts.filter(acc => acc.status === 'pending').length,
                    reauth: this.accounts.filter(acc => acc.status === 'reauth_needed').length,
                    codes: this.accounts.reduce((sum, acc) => sum + acc.codes.length, 0)
                };

                document.getElementById('totalAccounts').textContent = stats.total;
                document.getElementById('authorizedAccounts').textContent = stats.authorized;
                document.getElementById('pendingAccounts').textContent = stats.pending;
                document.getElementById('reauthAccounts').textContent = stats.reauth;
                document.getElementById('totalCodes').textContent = stats.codes;
            }

            updateStorageIndicator() {
                try {
                    const data = JSON.stringify({ accounts: this.accounts });
                    const sizeInBytes = new Blob([data]).size;
                    const sizeInKB = (sizeInBytes / 1024).toFixed(1);

                    // ä¼°ç®—LocalStorageé™åˆ¶ (é€šå¸¸5-10MB)
                    const estimatedLimit = 5 * 1024; // 5MB
                    const percentage = Math.min((sizeInKB / estimatedLimit) * 100, 100);

                    document.getElementById('storageFill').style.width = `${percentage}%`;
                    document.getElementById('storageText').textContent = `${sizeInKB} KB`;

                    // æ ¹æ®ä½¿ç”¨é‡æ”¹å˜é¢œè‰²
                    const fillElement = document.getElementById('storageFill');
                    if (percentage > 80) {
                        fillElement.style.background = 'linear-gradient(90deg, #dc3545, #c82333)';
                    } else if (percentage > 60) {
                        fillElement.style.background = 'linear-gradient(90deg, #ffc107, #e0a800)';
                    } else {
                        fillElement.style.background = 'linear-gradient(90deg, #28a745, #007bff)';
                    }
                } catch (error) {
                    console.warn('æ›´æ–°å­˜å‚¨æŒ‡ç¤ºå™¨å¤±è´¥:', error);
                }
            }

            // éªŒè¯è´¦æˆ·æˆæƒï¼ˆç›´æ¥ä½¿ç”¨refresh tokenï¼‰
            async validateAccountAuth(accountId) {
                const account = this.accounts.find(acc => acc.id === accountId);
                if (!account || !account.client_id || !account.refresh_token) {
                    this.showToast('è´¦æˆ·ç¼ºå°‘å¿…è¦çš„æˆæƒä¿¡æ¯', 'error');
                    return;
                }

                try {
                    this.showToast('æ­£åœ¨éªŒè¯è´¦æˆ·æˆæƒ...', 'info');

                    // ä½¿ç”¨ä»£ç†æœåŠ¡å™¨è°ƒç”¨Microsoft tokenåˆ·æ–°ç«¯ç‚¹
                    const PROXY_URL = 'http://localhost:3001/api/microsoft/token';
                    const response = await fetch(PROXY_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: account.client_id,
                            refresh_token: account.refresh_token,
                            grant_type: 'refresh_token',
                            scope: 'https://outlook.office.com/Mail.ReadWrite https://outlook.office.com/IMAP.AccessAsUser.All https://outlook.office.com/POP.AccessAsUser.All https://outlook.office.com/SMTP.Send'
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        const accessToken = data.access_token;
                        const expiresIn = data.expires_in || 3600;

                        // æ›´æ–°è´¦æˆ·çŠ¶æ€å’Œtoken
                        this.updateAccountStatus(accountId, 'authorized', {
                            access_token: accessToken,
                            expires_at: new Date(Date.now() + expiresIn * 1000).toISOString()
                        });

                        this.showToast('è´¦æˆ·æˆæƒéªŒè¯æˆåŠŸï¼', 'success');

                        // è‡ªåŠ¨å¼€å§‹é‚®ä»¶åŒæ­¥
                        setTimeout(() => {
                            this.syncAccountEmails(accountId);
                        }, 1000);

                        return { success: true, access_token: accessToken };

                    } else {
                        const errorData = await response.text();
                        console.error('TokenéªŒè¯å¤±è´¥:', response.status, errorData);

                        this.updateAccountStatus(accountId, 'reauth_needed');
                        this.showToast('æˆæƒéªŒè¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‡­æ®æ˜¯å¦æ­£ç¡®', 'error');

                        return { success: false, error: `HTTP ${response.status}` };
                    }

                } catch (error) {
                    console.error('éªŒè¯è´¦æˆ·æˆæƒå¤±è´¥:', error);
                    this.updateAccountStatus(accountId, 'reauth_needed');
                    this.showToast('æˆæƒéªŒè¯å¤±è´¥: ' + error.message, 'error');
                    return { success: false, error: error.message };
                }
            }

            async handleOAuthCallback(accountId) {
                try {
                    // æ›´æ–°è¿›åº¦
                    document.getElementById('oauthProgressText').textContent = 'æ­£åœ¨è·å–è®¿é—®ä»¤ç‰Œ...';
                    document.getElementById('oauthProgressFill').style.width = '60%';

                    // è¿™é‡Œåº”è¯¥å¤„ç†OAuthå›è°ƒå¹¶è·å–token
                    // ä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬æ¨¡æ‹ŸæˆåŠŸè·å–token
                    await new Promise(resolve => setTimeout(resolve, 2000));

                    // æ¨¡æ‹Ÿtokenæ•°æ®
                    const mockTokens = {
                        access_token: 'mock_access_token_' + Date.now(),
                        refresh_token: 'mock_refresh_token_' + Date.now(),
                        expires_at: new Date(Date.now() + 3600 * 1000).toISOString()
                    };

                    // æ›´æ–°è´¦æˆ·çŠ¶æ€
                    this.updateAccountStatus(accountId, 'authorized', mockTokens);

                    // æ·»åŠ ä¸€äº›ç¤ºä¾‹éªŒè¯ç 
                    this.addVerificationCode(accountId, '123456', 'Microsoft', new Date().toISOString());

                    document.getElementById('oauthProgressFill').style.width = '100%';
                    document.getElementById('oauthProgressText').textContent = 'æˆæƒå®Œæˆï¼';

                    setTimeout(() => {
                        document.getElementById('oauthModal').style.display = 'none';
                        this.showToast('æˆæƒæˆåŠŸï¼', 'success');
                        this.render();
                        this.updateStats();
                    }, 1500);

                } catch (error) {
                    console.error('å¤„ç†OAuthå›è°ƒå¤±è´¥:', error);
                    this.showToast('æˆæƒå¤±è´¥: ' + error.message, 'error');
                    document.getElementById('oauthModal').style.display = 'none';
                }
            }

            // åŒæ­¥é‚®ä»¶
            async syncAccountEmails(accountId) {
                const account = this.accounts.find(acc => acc.id === accountId);
                if (!account || account.status !== 'authorized' || !account.access_token) {
                    throw new Error('è´¦æˆ·æœªæˆæƒæˆ–æ— æ•ˆ');
                }

                try {
                    this.showToast('æ­£åœ¨åŒæ­¥é‚®ä»¶...', 'info');

                    // è°ƒç”¨Outlook REST APIè·å–é‚®ä»¶
                    const emails = await this.fetchOutlookEmails(account.access_token);

                    // æå–éªŒè¯ç 
                    const extractedCodes = this.extractVerificationCodes(emails);

                    // æ·»åŠ æ–°éªŒè¯ç 
                    let newCodesCount = 0;
                    for (const codeData of extractedCodes) {
                        const exists = account.codes.some(code =>
                            code.code === codeData.code &&
                            code.sender === codeData.sender &&
                            code.messageId === codeData.messageId
                        );

                        if (!exists) {
                            this.addVerificationCode(
                                accountId,
                                codeData.code,
                                codeData.sender,
                                codeData.received_at
                            );
                            newCodesCount++;
                        }
                    }

                    account.last_sync = new Date().toISOString();
                    this.saveAccounts();

                    if (newCodesCount > 0) {
                        this.showToast(`åŒæ­¥å®Œæˆï¼Œå‘ç° ${newCodesCount} ä¸ªæ–°éªŒè¯ç `, 'success');
                    } else {
                        this.showToast('åŒæ­¥å®Œæˆï¼Œæœªå‘ç°æ–°éªŒè¯ç ', 'info');
                    }

                    return newCodesCount;

                } catch (error) {
                    console.error('åŒæ­¥é‚®ä»¶å¤±è´¥:', error);

                    // å¦‚æœtokenè¿‡æœŸï¼Œå°è¯•é‡æ–°éªŒè¯
                    if (error.message.includes('401') || error.message.includes('Unauthorized')) {
                        this.updateAccountStatus(accountId, 'reauth_needed');
                        this.showToast('è®¿é—®ä»¤ç‰Œå·²è¿‡æœŸï¼Œè¯·é‡æ–°æˆæƒ', 'warning');
                    } else {
                        this.showToast('åŒæ­¥é‚®ä»¶å¤±è´¥: ' + error.message, 'error');
                    }

                    throw error;
                }
            }

            // è°ƒç”¨Outlook REST APIè·å–é‚®ä»¶
            async fetchOutlookEmails(accessToken) {
                // ä½¿ç”¨ä»£ç†æœåŠ¡å™¨è°ƒç”¨Outlook API
                const PROXY_URL = 'http://localhost:3001/api/outlook/api/v2.0/me/messages?$orderby=ReceivedDateTime desc&$top=5';

                const response = await fetch(PROXY_URL, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Content-Type': 'application/json',
                    }
                });

                if (!response.ok) {
                    throw new Error(`Outlook APIè°ƒç”¨å¤±è´¥: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                return data.value || [];
            }

            // ä»é‚®ï¿½ï¿½ä¸­æå–éªŒè¯ç ï¼ˆä¸åŸç³»ç»Ÿç›¸åŒçš„ç®—æ³•ï¼‰
            extractVerificationCodes(messages) {
                const verificationCodes = [];
                const verificationPatterns = [
                    // å¸¸è§çš„éªŒè¯ç æ¨¡å¼
                    /\b\d{4,8}\b/g,  // 4-8ä½æ•°å­—
                    /(?:code|verification|éªŒè¯ç )[\s:ï¼š]*(\d{4,8})/gi,
                    /(?:verification code|éªŒè¯ç )[\s:ï¼š]*(\d{4,8})/gi,
                    /(?:pin|å¯†ç )[\s:ï¼š]*(\d{4,8})/gi,
                    // é‚®ä»¶æ ‡é¢˜ä¸­çš„éªŒè¯ç 
                    /^\[.*?(\d{4,8}).*?\]/gm,
                    // åŒ…å«"éªŒè¯"çš„æ•°å­—ç»„åˆ
                    /(?:éªŒè¯|verification).*?(\d{4,8})/gi
                ];

                for (const message of messages) {
                    const subject = message.Subject || message.subject || 'æ— æ ‡é¢˜';
                    const from = message.From || message.from;
                    const receivedDateTime = message.ReceivedDateTime || message.receivedDateTime;
                    const messageId = message.Id || message.id;
                    const bodyContent = message.Body?.Content || message.body?.content || '';

                    // æ¸…ç†HTMLå†…å®¹ï¼Œåªä¿ç•™æ–‡æœ¬
                    const cleanContent = bodyContent.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();

                    // åœ¨ä¸»é¢˜å’Œå†…å®¹ä¸­æœç´¢éªŒè¯ç 
                    const searchContent = `${subject} ${cleanContent}`;
                    const potentialCodes = [];

                    for (const pattern of verificationPatterns) {
                        const matches = [...searchContent.matchAll(pattern)];
                        for (const match of matches) {
                            const code = match[1] || match[0];
                            if (code && /^\d{4,8}$/.test(code)) {
                                potentialCodes.push(code);
                            }
                        }
                    }

                    // éªŒè¯ç éªŒè¯é€»è¾‘ï¼ˆä¸åŸç³»ç»Ÿä¿æŒä¸€è‡´ï¼‰
                    for (const code of potentialCodes) {
                        // è·³è¿‡æ˜æ˜¾æ— æ•ˆçš„æ•°å­—
                        if (this.isValidVerificationCode(code, searchContent)) {
                            verificationCodes.push({
                                code: code,
                                subject: subject,
                                sender: from?.EmailAddress?.Name || from?.emailAddress || 'Unknown',
                                received_at: receivedDateTime,
                                messageId: messageId
                            });
                        }
                    }
                }

                // å»é‡ï¼ˆç›¸åŒçš„éªŒè¯ç åªä¿ç•™æœ€æ–°çš„ï¼‰
                const uniqueCodes = [];
                const seenCodes = new Set();

                for (const codeData of verificationCodes) {
                    const key = `${codeData.code}_${codeData.sender}`;
                    if (!seenCodes.has(key)) {
                        seenCodes.add(key);
                        uniqueCodes.push(codeData);
                    }
                }

                return uniqueCodes;
            }

            // éªŒè¯ç æœ‰æ•ˆæ€§éªŒè¯
            isValidVerificationCode(code, content) {
                // è·³è¿‡å¹´ä»½ï¼ˆå¦‚2024, 2023ç­‰ï¼‰
                if (/^(19|20)\d{2}$/.test(code)) {
                    return false;
                }

                // è·³è¿‡ç”µè¯å·ç æ ¼å¼
                if (code.startsWith('1') && code.length === 10) {
                    return false;
                }

                // è·³è¿‡å¸¸è§çš„ééªŒè¯ç æ•°å­—
                const invalidPatterns = [
                    /^000000/,  // å…¨é›¶
                    /^123456/,  // å¸¸è§æµ‹è¯•æ•°å­—
                    /^111111/,
                    /^222222/
                ];

                if (invalidPatterns.some(pattern => pattern.test(code))) {
                    return false;
                }

                // æ£€æŸ¥æ˜¯å¦åœ¨éªŒè¯ç›¸å…³çš„ä¸Šä¸‹æ–‡ä¸­
                const verificationContexts = [
                    'verification', 'verify', 'code', 'éªŒè¯ç ', 'éªŒè¯', 'code',
                    'pin', 'password', 'å¯†ç ', 'otp', 'one-time', 'ä¸€æ¬¡æ€§'
                ];

                const contentLower = content.toLowerCase();
                const hasVerificationContext = verificationContexts.some(context =>
                    contentLower.includes(context)
                );

                // å¦‚æœæœ‰éªŒè¯ä¸Šä¸‹æ–‡ï¼Œæˆ–è€…ä»£ç é•¿åº¦ä¸º6ä½ï¼Œåˆ™è®¤ä¸ºæ˜¯æœ‰æ•ˆçš„éªŒè¯ç 
                return hasVerificationContext || code.length === 6;
            }

            // æ‰¹é‡å¯¼å…¥
            handleBulkImportFile(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    const accounts = this.parseAccountCSV(content);

                    if (accounts.length === 0) {
                        this.showToast('æ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„è´¦æˆ·æ•°æ®', 'warning');
                        return;
                    }

                    // æ˜¾ç¤ºé¢„è§ˆ
                    this.showBulkImportPreview(accounts);
                    document.getElementById('selectedFileName').textContent = file.name;
                    document.getElementById('startBulkImport').disabled = false;
                };

                reader.readAsText(file);
            }

            parseAccountCSV(content) {
                const lines = content.split('\n');
                const accounts = [];
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

                for (const line of lines) {
                    const trimmed = line.trim();
                    if (!trimmed || trimmed.startsWith('#')) continue; // è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Š

                    // æ”¯æŒCSVæ ¼å¼ï¼šemail,client_id,refresh_token
                    const parts = trimmed.split(',').map(part => part.trim());

                    if (parts.length >= 3) {
                        const [email, clientId, refreshToken] = parts;

                        if (emailRegex.test(email) && clientId && refreshToken) {
                            accounts.push({
                                email: email,
                                client_id: clientId,
                                refresh_token: refreshToken,
                                name: email // é»˜è®¤ä½¿ç”¨é‚®ç®±ä½œä¸ºæ˜¾ç¤ºåç§°
                            });
                        }
                    }
                }

                // å»é‡ï¼ˆåŸºäºé‚®ç®±åœ°å€ï¼‰
                const uniqueAccounts = [];
                const seenEmails = new Set();

                for (const account of accounts) {
                    if (!seenEmails.has(account.email)) {
                        seenEmails.add(account.email);
                        uniqueAccounts.push(account);
                    }
                }

                return uniqueAccounts;
            }

            showBulkImportPreview(accounts) {
                const previewList = document.getElementById('previewList');
                const previewAccounts = accounts.slice(0, 10);

                previewList.innerHTML = previewAccounts.map(account =>
                    `<div style="padding: 8px 0; border-bottom: 1px solid #dee2e6;">
                        <div style="font-weight: 500;">${account.name}</div>
                        <div style="font-size: 12px; color: #6c757d;">${account.email}</div>
                        <div style="font-size: 11px; color: #999;">Client ID: ${account.client_id.substring(0, 10)}...</div>
                    </div>`
                ).join('');

                if (accounts.length > 10) {
                    previewList.innerHTML += `
                        <div style="padding: 8px 0; color: #6c757d; font-style: italic;">
                            ... è¿˜æœ‰ ${accounts.length - 10} ä¸ªè´¦æˆ·
                        </div>
                    `;
                }

                document.getElementById('bulkImportPreview').style.display = 'block';
            }

            async startBulkImport() {
                const fileInput = document.getElementById('bulkImportFile');
                const file = fileInput.files[0];

                if (!file) return;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    const content = e.target.result;
                    const accounts = this.parseAccountCSV(content);

                    if (accounts.length === 0) {
                        this.showToast('æ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„è´¦æˆ·æ•°æ®', 'warning');
                        return;
                    }

                    await this.performBulkImport(accounts);
                };

                reader.readAsText(file);
            }

            async performBulkImport(accounts) {
                const progressSection = document.getElementById('bulkImportProgress');
                const progressFill = document.getElementById('importProgressFill');
                const statusText = document.getElementById('importStatusText');

                progressSection.style.display = 'block';
                document.getElementById('startBulkImport').disabled = true;

                let successCount = 0;
                let errorCount = 0;
                const errors = [];

                for (let i = 0; i < accounts.length; i++) {
                    const accountData = accounts[i];
                    const progress = ((i + 1) / accounts.length) * 100;

                    try {
                        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
                        if (this.accounts.some(acc => acc.email === accountData.email)) {
                            errors.push(`${accountData.email}: è´¦æˆ·å·²å­˜åœ¨`);
                            errorCount++;
                        } else {
                            // æ·»åŠ è´¦æˆ·
                            const account = this.addAccount(
                                accountData.email,
                                accountData.name,
                                accountData.client_id,
                                accountData.refresh_token
                            );
                            successCount++;

                            // è‡ªåŠ¨éªŒè¯æˆæƒï¼ˆå¼‚æ­¥ï¼Œä¸é˜»å¡å¯¼å…¥è¿‡ç¨‹ï¼‰
                            setTimeout(() => {
                                this.validateAccountAuth(account.id);
                            }, 1000 * i); // é”™å¼€éªŒè¯æ—¶é—´
                        }
                    } catch (error) {
                        errors.push(`${accountData.email}: ${error.message}`);
                        errorCount++;
                    }

                    // æ›´æ–°è¿›åº¦
                    progressFill.style.width = `${progress}%`;
                    statusText.textContent = `æ­£åœ¨å¯¼å…¥ ${i + 1}/${accounts.length} (æˆåŠŸ: ${successCount}, å¤±è´¥: ${errorCount})`;
                }

                // å®Œæˆå¯¼å…¥
                await this.saveAccounts();
                this.filteredAccounts = [...this.accounts];
                this.render();
                this.updateStats();
                this.updateStorageIndicator();

                // æ˜¾ç¤ºç»“æœ
                const message = `æ‰¹é‡å¯¼å…¥å®Œæˆï¼\næˆåŠŸ: ${successCount}\nå¤±è´¥: ${errorCount}`;
                if (errorCount > 0) {
                    console.warn('å¯¼å…¥é”™è¯¯:', errors);
                    this.showToast(message, 'warning');
                } else {
                    this.showToast(message, 'success');
                }

                // é‡ç½®ç•Œé¢
                setTimeout(() => {
                    this.closeBulkImport();
                }, 3000);
            }

            closeBulkImport() {
                document.getElementById('bulkImportSection').style.display = 'none';
                document.getElementById('bulkImportFile').value = '';
                document.getElementById('selectedFileName').textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                document.getElementById('startBulkImport').disabled = true;
                document.getElementById('bulkImportPreview').style.display = 'none';
                document.getElementById('bulkImportProgress').style.display = 'none';
            }

            // å¯¼å‡ºæ•°æ®
            exportData() {
                if (this.accounts.length === 0) {
                    this.showToast('æš‚æ— æ•°æ®å¯å¯¼å‡º', 'warning');
                    return;
                }

                const exportData = {
                    accounts: this.accounts,
                    export_time: new Date().toISOString(),
                    version: '2.0',
                    statistics: {
                        total_accounts: this.accounts.length,
                        authorized_accounts: this.accounts.filter(acc => acc.status === 'authorized').length,
                        total_codes: this.accounts.reduce((sum, acc) => sum + acc.codes.length, 0)
                    }
                };

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mailmanager_backup_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.showToast('æ•°æ®å¯¼å‡ºæˆåŠŸ', 'success');
            }

            // å®šæœŸåŒæ­¥
            startPeriodicSync() {
                // æ¯5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡éœ€è¦åŒæ­¥çš„è´¦æˆ·
                setInterval(() => {
                    this.autoSyncAccounts();
                }, 5 * 60 * 1000);

                // æ¯å°æ—¶æ£€æŸ¥tokenè¿‡æœŸ
                setInterval(() => {
                    this.checkTokenExpiry();
                }, 60 * 60 * 1000);
            }

            async autoSyncAccounts() {
                const authorizedAccounts = this.accounts.filter(acc => acc.status === 'authorized');
                const syncInterval = 30 * 60 * 1000; // 30åˆ†é’Ÿ

                for (const account of authorizedAccounts) {
                    const lastSync = account.last_sync ? new Date(account.last_sync).getTime() : 0;
                    const now = Date.now();

                    if (now - lastSync > syncInterval) {
                        try {
                            await this.syncAccountEmails(account.id);
                            console.log(`è‡ªåŠ¨åŒæ­¥è´¦æˆ·: ${account.email}`);
                        } catch (error) {
                            console.error(`è‡ªåŠ¨åŒæ­¥å¤±è´¥ ${account.email}:`, error);
                        }
                    }
                }
            }

            checkTokenExpiry() {
                const now = Date.now();
                const expiryThreshold = 24 * 60 * 60 * 1000; // 24å°æ—¶

                for (const account of this.accounts) {
                    if (account.access_token && account.token_expires_at) {
                        const expiryTime = new Date(account.token_expires_at).getTime();

                        if (expiryTime - now < expiryThreshold) {
                            this.updateAccountStatus(account.id, 'reauth_needed');
                            console.log(`è´¦æˆ·éœ€è¦é‡æ–°æˆæƒ: ${account.email}`);
                        }
                    }
                }
            }

            // å·¥å…·æ–¹æ³•
            getStatusText(status) {
                const statusMap = {
                    'authorized': 'å·²æˆæƒ',
                    'pending': 'å¾…æˆæƒ',
                    'reauth_needed': 'éœ€é‡æ–°æˆæƒ'
                };
                return statusMap[status] || 'æœªçŸ¥';
            }

            formatTime(timeString) {
                if (!timeString) return '---';

                const date = new Date(timeString);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) return 'åˆšåˆš';
                if (diffMins < 60) return `${diffMins}åˆ†é’Ÿå‰`;
                if (diffHours < 24) return `${diffHours}å°æ—¶å‰`;
                if (diffDays < 7) return `${diffDays}å¤©å‰`;

                return date.toLocaleDateString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            showToast(message, type = 'info') {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.innerHTML = `
                    <span>${message}</span>
                `;

                document.body.appendChild(toast);

                setTimeout(() => {
                    toast.remove();
                }, 4000);
            }
        }

        // å…¨å±€å®ä¾‹
        let mailManager;

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            mailManager = new BrowserMailManager();
        });

        // å…¨å±€å‡½æ•°
        function openAddAccountModal() {
            document.getElementById('addAccountModal').style.display = 'block';
            document.getElementById('newAccountEmail').focus();
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        function addAccount(event) {
            event.preventDefault();

            const email = document.getElementById('newAccountEmail').value.trim();
            const name = document.getElementById('newAccountName').value.trim();
            const clientId = document.getElementById('newAccountClientId').value.trim();
            const refreshToken = document.getElementById('newAccountRefreshToken').value.trim();

            if (!email || !clientId || !refreshToken) {
                mailManager.showToast('è¯·å¡«å†™æ‰€æœ‰å¿…å¡«å­—æ®µ', 'error');
                return;
            }

            try {
                const account = mailManager.addAccount(email, name, clientId, refreshToken);
                mailManager.filteredAccounts = [...mailManager.accounts];
                mailManager.render();
                mailManager.updateStats();
                mailManager.updateStorageIndicator();

                closeModal('addAccountModal');
                document.getElementById('addAccountForm').reset();

                // è‡ªåŠ¨éªŒè¯æˆæƒçŠ¶æ€
                mailManager.validateAccountAuth(account.id);

            } catch (error) {
                mailManager.showToast(error.message, 'error');
            }
        }

        function openBulkImportModal() {
            document.getElementById('bulkImportSection').style.display = 'block';
        }

        function closeBulkImport() {
            mailManager.closeBulkImport();
        }

        function startBulkImport() {
            mailManager.startBulkImport();
        }

        function searchAccounts(query) {
            mailManager.searchAccounts(query);
        }

        function filterByStatus(status) {
            mailManager.filterByStatus(status);
        }

        function sortTable(field) {
            mailManager.sortTable(field);
        }

        function toggleSelectAll() {
            const selectAll = document.getElementById('selectAll');
            const checkboxes = document.querySelectorAll('.account-checkbox');

            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAll.checked;
                const accountId = checkbox.dataset.accountId;
                if (selectAll.checked) {
                    mailManager.selectedAccounts.add(accountId);
                } else {
                    mailManager.selectedAccounts.delete(accountId);
                }
            });
        }

        function toggleAccountSelection(accountId, isSelected) {
            if (isSelected) {
                mailManager.selectedAccounts.add(accountId);
            } else {
                mailManager.selectedAccounts.delete(accountId);
            }

            // æ›´æ–°å…¨é€‰çŠ¶æ€
            const allCheckboxes = document.querySelectorAll('.account-checkbox');
            const checkedCount = document.querySelectorAll('.account-checkbox:checked').length;
            document.getElementById('selectAll').checked = checkedCount === allCheckboxes.length;
        }

        function changePage(direction) {
            const totalPages = Math.ceil(mailManager.filteredAccounts.length / mailManager.itemsPerPage);
            const newPage = mailManager.currentPage + direction;

            if (newPage >= 1 && newPage <= totalPages) {
                mailManager.currentPage = newPage;
                mailManager.render();
            }
        }

        function syncAccount(accountId) {
            const account = mailManager.accounts.find(acc => acc.id === accountId);
            if (!account) return;

            if (account.status !== 'authorized') {
                mailManager.startOAuthFlow(accountId);
                return;
            }

            // æ˜¾ç¤ºåŒæ­¥è¿›åº¦
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.innerHTML = '<span class="loading"></span> åŒæ­¥ä¸­';
            btn.disabled = true;

            mailManager.syncAccountEmails(accountId).then((codesCount) => {
                mailManager.render();
                mailManager.updateStats();
                mailManager.showToast(`åŒæ­¥å®Œæˆï¼Œå‘ç° ${codesCount} ä¸ªæ–°éªŒè¯ç `, 'success');
            }).catch((error) => {
                mailManager.showToast('åŒæ­¥å¤±è´¥: ' + error.message, 'error');
            }).finally(() => {
                btn.innerHTML = originalText;
                btn.disabled = false;
            });
        }

        function reauthAccount(accountId) {
            mailManager.startOAuthFlow(accountId);
        }

        function deleteAccount(accountId) {
            const account = mailManager.accounts.find(acc => acc.id === accountId);
            if (!account) return;

            if (confirm(`ç¡®å®šè¦åˆ é™¤è´¦æˆ· "${account.name}" å—ï¼Ÿ\n\næ­¤æ“ä½œå°†åˆ é™¤è¯¥è´¦æˆ·çš„æ‰€æœ‰æ•°æ®ï¼ŒåŒ…æ‹¬éªŒè¯ç è®°å½•ã€‚`)) {
                mailManager.deleteAccount(accountId);
                mailManager.filteredAccounts = [...mailManager.accounts];
                mailManager.render();
                mailManager.updateStats();
                mailManager.updateStorageIndicator();
                mailManager.showToast('è´¦æˆ·åˆ é™¤æˆåŠŸ', 'success');
            }
        }

        function bulkSync() {
            const selectedAccounts = Array.from(mailManager.selectedAccounts);

            if (selectedAccounts.length === 0) {
                mailManager.showToast('è¯·å…ˆé€‰æ‹©è¦åŒæ­¥çš„è´¦æˆ·', 'warning');
                return;
            }

            let successCount = 0;
            let errorCount = 0;
            let completed = 0;

            selectedAccounts.forEach(accountId => {
                const account = mailManager.accounts.find(acc => acc.id === accountId);
                if (!account) return;

                if (account.status !== 'authorized') {
                    errorCount++;
                    completed++;
                    return;
                }

                // å¼‚æ­¥åŒæ­¥æ¯ä¸ªè´¦æˆ·
                mailManager.syncAccountEmails(accountId).then(() => {
                    successCount++;
                    completed++;

                    if (completed === selectedAccounts.length) {
                        mailManager.render();
                        mailManager.updateStats();
                        mailManager.showToast(
                            `æ‰¹é‡åŒæ­¥å®Œæˆï¼æˆåŠŸ: ${successCount}, å¤±è´¥: ${errorCount}`,
                            errorCount === 0 ? 'success' : 'warning'
                        );
                    }
                }).catch(() => {
                    errorCount++;
                    completed++;

                    if (completed === selectedAccounts.length) {
                        mailManager.render();
                        mailManager.updateStats();
                        mailManager.showToast(
                            `æ‰¹é‡åŒæ­¥å®Œæˆï¼æˆåŠŸ: ${successCount}, å¤±è´¥: ${errorCount}`,
                            'warning'
                        );
                    }
                });
            });
        }

        function exportData() {
            mailManager.exportData();
        }

        function refreshData() {
            mailManager.render();
            mailManager.updateStats();
            mailManager.updateStorageIndicator();
            mailManager.showToast('æ•°æ®å·²åˆ·æ–°', 'success');
        }

        function startOAuth() {
            const email = document.getElementById('oauthEmail').textContent;
            const account = mailManager.accounts.find(acc => acc.email === email);
            if (account) {
                mailManager.startOAuthFlow(account.id);
            }
        }

        // OAuthå›è°ƒå¤„ç† (éœ€è¦åœ¨å®é™…éƒ¨ç½²æ—¶é…ç½®æ­£ç¡®çš„URL)
        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const state = urlParams.get('state');
            const error = urlParams.get('error');

            if (code && state) {
                // å¤„ç†OAuthæˆåŠŸå›è°ƒ
                console.log('OAuthå›è°ƒ:', { code, state });
                // è¿™é‡Œåº”è¯¥äº¤æ¢codeè·å–token
                // ç„¶åå…³é—­å¼¹çª—å¹¶æ›´æ–°è´¦æˆ·çŠ¶æ€
                window.close();
            } else if (error) {
                // å¤„ç†OAuthé”™è¯¯
                console.error('OAuthé”™è¯¯:', error);
                window.close();
            }
        });
    </script>
</body>
</html>