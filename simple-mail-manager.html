<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MailManager - ç®€åŒ–ç®¡ç†ç•Œé¢</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .status-pending { color: #F59E0B; }
        .status-authorized { color: #10B981; }
        .status-error { color: #EF4444; }
        .monitoring { animation: pulse 2s infinite; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .code-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.9em;
        }
        .text-code {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 1em;
        }
        .simple-pagination {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .page-btn {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            background: white;
            color: #374151;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .page-btn:hover {
            background: #f3f4f6;
        }
        .page-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        .page-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .search-filter {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            width: 200px;
        }
        .code-cell {
            min-width: 120px;
            white-space: nowrap;
        }
        .stats-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            background: #f8fafc;
            padding: 15px;
            border-radius: 8px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #1f2937;
        }
        .stat-label {
            color: #6b7280;
            font-size: 1.1em;
            font-weight: 500;
        }
        .refresh-loading {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="container mx-auto px-4 py-6 max-w-7xl">
        <!-- å¤´éƒ¨ -->
        <div class="bg-white rounded-lg shadow-sm p-6 mb-6">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-3xl font-bold text-gray-900">
                        <i class="fas fa-envelope mr-3"></i>MailManager
                    </h1>
                    <p class="text-lg text-gray-600 mt-2">ç®€å•é«˜æ•ˆçš„é‚®ç®±éªŒè¯ç ç®¡ç†</p>
                </div>
                <div class="flex gap-3">
                    <button onclick="showImportModal()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition">
                        <i class="fas fa-file-import mr-1"></i>å¯¼å…¥é‚®ç®±
                    </button>
                    <button onclick="refreshData()" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg transition" title="é‡æ–°åŠ è½½æ•°æ®å¹¶è¿æ¥å®æ—¶æ›´æ–°">
                        <i class="fas fa-redo mr-1"></i>é‡æ–°åŠ è½½
                    </button>
                    <button onclick="confirmClearAllData()" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg transition">
                        <i class="fas fa-trash-alt mr-1"></i>æ¸…ç©ºæ•°æ®
                    </button>
                </div>
            </div>
        </div>

        <!-- ç»Ÿè®¡ä¿¡æ¯ -->
        <div class="stats-row" style="position: relative;">
            <div class="stat-item">
                <div class="stat-number" id="totalAccounts">0</div>
                <div class="stat-label">æ€»è´¦æˆ·æ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-number text-green-600" id="authorizedCount">0</div>
                <div class="stat-label">å·²æˆæƒ</div>
            </div>
            <div class="stat-item">
                <div class="stat-number text-yellow-600" id="pendingCount">0</div>
                <div class="stat-label">å¾…æˆæƒ</div>
            </div>
            <div class="stat-item">
                <div class="stat-number text-purple-600" id="monitoringCount">0</div>
                <div class="stat-label">ç›‘æ§ä¸­</div>
            </div>
            <!-- ç³»ç»ŸåŠŸèƒ½å’Œå®‰å…¨è¯´æ˜ - åœ¨ç»Ÿè®¡è¡Œå³ä¾§ç©ºç™½å¤„ -->
            <div class="system-info" style="position: absolute; right: 20px; top: 50%; transform: translateY(-50%); max-width: 600px;">
                <div style="display: flex; gap: 30px;">
                    <!-- æ ¸å¿ƒåŠŸèƒ½ -->
                    <div>
                        <div style="display: flex; align-items: center; font-size: 16px; color: #374151; margin-bottom: 6px;">
                            <i class="fas fa-star" style="color: #f59e0b; margin-right: 8px; font-size: 14px;"></i>
                            <span style="font-weight: 600;">æ ¸å¿ƒåŠŸèƒ½:</span>
                        </div>
                        <div style="font-size: 14px; color: #6b7280; line-height: 1.5; margin-left: 22px;">
                            <div>â€¢ ä¸€é”®å¤åˆ¶é‚®ç®±ï¼Œè‡ªåŠ¨ç›‘æ§æ›´æ–°éªŒè¯ç </div>
                            <div>â€¢ ä¸€é”®å¤åˆ¶éªŒè¯ç ï¼Œå¿«é€Ÿå®ŒæˆéªŒè¯</div>
                            <div>â€¢ æ™ºèƒ½æ—¶é—´è¿½è¸ªï¼ŒæŒæ¡é‚®ç®±æ´»è·ƒçŠ¶æ€</div>
                        </div>
                    </div>

                    <!-- æ•°æ®å®‰å…¨ -->
                    <div>
                        <div style="display: flex; align-items: center; font-size: 16px; color: #374151; margin-bottom: 6px;">
                            <i class="fas fa-shield-alt" style="color: #10b981; margin-right: 8px; font-size: 14px;"></i>
                            <span style="font-weight: 600;">æ•°æ®å®‰å…¨:</span>
                        </div>
                        <div style="font-size: 14px; color: #6b7280; line-height: 1.5; margin-left: 22px;">
                            <div>â€¢ æœ¬åœ°å­˜å‚¨ï¼Œæ•°æ®ä»…ä¿å­˜åœ¨æµè§ˆå™¨</div>
                            <div>â€¢ åŠ å¯†ä¿æŠ¤ï¼Œæ•æ„Ÿä¿¡æ¯å®‰å…¨å­˜å‚¨</div>
                            <div>â€¢ éšç§å®‰å…¨ï¼Œç»ä¸ä¸Šä¼ ä»»ä½•æœåŠ¡å™¨</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- æœç´¢å’Œè¿‡æ»¤ -->
        <div class="bg-white rounded-lg shadow-sm p-4 mb-6">
            <div class="flex gap-4 items-center flex-wrap">
                <div class="flex items-center gap-2">
                    <label class="text-sm font-medium text-gray-700">æœç´¢:</label>
                    <input type="text" id="searchInput" placeholder="é‚®ç®±åœ°å€"
                           class="search-filter" onkeyup="filterAccounts()">
                </div>
                <div class="flex items-center gap-2">
                    <label class="text-sm font-medium text-gray-700">çŠ¶æ€:</label>
                    <select id="statusFilter" class="search-filter" onchange="filterAccounts()">
                        <option value="">å…¨éƒ¨</option>
                        <option value="pending">å¾…æˆæƒ</option>
                        <option value="authorized">å·²æˆæƒ</option>
                        <option value="reauth_needed">éœ€é‡æ–°æˆæƒ</option>
                    </select>
                </div>
                <div class="flex items-center gap-2">
                    <label class="text-sm font-medium text-gray-700">æ¯é¡µæ˜¾ç¤º:</label>
                    <select id="pageSize" class="search-filter" onchange="changePageSize()">
                        <option value="20">20</option>
                        <option value="50" selected>50</option>
                        <option value="100">100</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- è´¦æˆ·åˆ—è¡¨ -->
        <div class="bg-white rounded-lg shadow-sm">
            <div class="overflow-x-auto">
                <table class="w-full">
                    <thead class="bg-gray-50 border-b">
                        <tr>
                            <th class="px-3 py-3 text-left text-base font-medium text-gray-700 uppercase tracking-wider cursor-pointer hover:bg-gray-100 w-20" onclick="sortBySequence()">
                                <span class="flex items-center gap-1">
                                    åºå·
                                    <i id="seqSortIcon" class="fas fa-sort text-gray-400"></i>
                                </span>
                            </th>
                            <th class="px-3 py-3 text-left text-base font-medium text-gray-700 uppercase tracking-wider cursor-pointer hover:bg-gray-100 w-20" onclick="sortByStatus()">
                                <span class="flex items-center gap-1">
                                    çŠ¶æ€
                                    <i id="statusSortIcon" class="fas fa-sort text-gray-400"></i>
                                </span>
                            </th>
                            <th class="px-4 py-3 text-left text-base font-medium text-gray-700 uppercase tracking-wider cursor-pointer hover:bg-gray-100 w-34" onclick="sortByEmail()">
                                <span class="flex items-center gap-1">
                                    é‚®ç®±åœ°å€
                                    <i id="emailSortIcon" class="fas fa-sort text-gray-400"></i>
                                </span>
                            </th>
                            <th class="px-3 py-3 text-left text-base font-medium text-gray-700 uppercase tracking-wider w-16">é€‰ä¸­</th>
                            <th class="px-3 py-3 text-left text-base font-medium text-gray-700 uppercase tracking-wider w-32">æœ€æ–°éªŒè¯ç </th>
                            <th class="px-3 py-3 text-left text-base font-medium text-gray-700 uppercase tracking-wider cursor-pointer hover:bg-gray-100 w-36" onclick="sortByCodeTime()">
                                <span class="flex items-center gap-1">
                                    éªŒè¯ç æ—¶é—´
                                    <i id="codeTimeSortIcon" class="fas fa-sort text-gray-400"></i>
                                </span>
                            </th>
                            <th class="px-3 py-3 text-left text-base font-medium text-gray-700 uppercase tracking-wider cursor-pointer hover:bg-gray-100 w-28" onclick="sortBySender()">
                                <span class="flex items-center gap-1">
                                    å‘ä»¶äºº
                                    <i id="senderSortIcon" class="fas fa-sort text-gray-400"></i>
                                </span>
                            </th>
                            <th class="px-3 py-3 text-left text-base font-medium text-gray-700 uppercase tracking-wider w-64">æ“ä½œ</th>
                        </tr>
                    </thead>
                    <tbody id="accountsTableBody" class="bg-white divide-y divide-gray-200">
                        <!-- è´¦æˆ·æ•°æ®å°†åœ¨è¿™é‡ŒåŠ è½½ -->
                    </tbody>
                </table>
            </div>

            <!-- åˆ†é¡µæ§åˆ¶ -->
            <div class="px-6 py-4 border-t bg-gray-50">
                <div class="flex justify-between items-center">
                    <div class="text-sm text-gray-700">
                        æ˜¾ç¤º <span id="showingFrom">0</span> - <span id="showingTo">0</span>
                        å…± <span id="totalRecords">0</span> æ¡è®°å½•
                    </div>
                    <div class="simple-pagination" id="pagination">
                        <!-- åˆ†é¡µæŒ‰é’®å°†åœ¨è¿™é‡Œç”Ÿæˆ -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- å¯¼å…¥é‚®ç®±å¼¹çª— -->
    <div id="importModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg p-6 w-full max-w-2xl max-h-[80vh] overflow-auto">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-900">
                    <i class="fas fa-file-import mr-2"></i>å¯¼å…¥é‚®ç®±
                </h2>
                <button onclick="hideImportModal()" class="text-gray-500 hover:text-gray-700">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>

            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">
                    é‚®ç®±ä¿¡æ¯æ ¼å¼
                </label>
                <div class="bg-gray-50 p-3 rounded border text-sm text-gray-600 mb-4">
                    æ ¼å¼ï¼šé‚®ç®±åœ°å€----å¯†ç ----Client ID----Refresh Token<br>
                    ï¼ˆæ¯è¡Œä¸€ä¸ªé‚®ç®±ä¿¡æ¯ï¼Œä½¿ç”¨å››ä¸ª----åˆ†éš”ï¼Œæ”¯æŒæ™ºèƒ½UUIDè¯†åˆ«ï¼‰<br>
                    <span class="text-amber-600 font-medium">ğŸ’¡ å»ºè®®ä¸€æ¬¡å¯¼å…¥ä¸è¶…è¿‡1000ä¸ªé‚®ç®±ï¼Œä»¥ç¡®ä¿æœ€ä½³æ€§èƒ½</span>
                </div>

                <label class="block text-sm font-medium text-gray-700 mb-2">
                    è¯·è¾“å…¥é‚®ç®±ä¿¡æ¯ï¼ˆä¸€è¡Œä¸€ä¸ªï¼‰
                </label>
                <textarea
                    id="importTextarea"
                    rows="10"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="example@outlook.com----password123----client_id_value----refresh_token_value&#10;user2@outlook.com----password456----client_id_2----refresh_token_2"
                ></textarea>
            </div>

            <div class="flex justify-end gap-3">
                <button onclick="hideImportModal()"
                        class="bg-gray-300 hover:bg-gray-400 text-gray-800 px-4 py-2 rounded-md">
                    å–æ¶ˆ
                </button>
                <button onclick="importEmails()"
                        class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md">
                    <i class="fas fa-file-import mr-1"></i>å¯¼å…¥é‚®ç®±
                </button>
            </div>
        </div>
    </div>

    <!-- å¯¼å…¥è¿›åº¦å¼¹çª— -->
    <div id="importProgressModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg p-6 w-96">
            <!-- å¯¼å…¥ä¸­çŠ¶æ€ -->
            <div id="importingStatus">
                <h3 class="text-lg font-bold text-gray-900 mb-4">
                    <i class="fas fa-spinner fa-spin mr-2"></i>æ­£åœ¨å¯¼å…¥é‚®ç®±
                </h3>
                <div class="mb-4">
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div id="progressBar" class="bg-blue-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                    <p class="text-sm text-gray-600 mt-2" id="progressText">å‡†å¤‡å¯¼å…¥...</p>
                </div>
                <div class="text-sm text-gray-500">
                    <span id="progressCount">0/0</span> ä¸ªé‚®ç®±
                </div>
            </div>

            <!-- å®ŒæˆçŠ¶æ€ -->
            <div id="importCompleteStatus" class="hidden">
                <div class="text-center mb-4">
                    <div class="inline-block bg-green-100 rounded-full p-3">
                        <i class="fas fa-check text-green-500 text-2xl"></i>
                    </div>
                </div>
                <h3 class="text-lg font-bold text-gray-900 mb-2 text-center">å¯¼å…¥å®Œæˆ</h3>
                <div class="mb-4 text-center">
                    <p class="text-gray-700" id="importResultText"></p>
                </div>
            </div>

            <!-- å…³é—­æŒ‰é’® -->
            <div id="importCloseButton" class="hidden">
                <button onclick="closeImportProgressModal()" class="w-full bg-blue-600 text-white py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors">
                    ç¡®å®š
                </button>
            </div>
        </div>
    </div>

    <!-- æ¸…ç©ºæ•°æ®ç¡®è®¤å¼¹çª— -->
    <div id="clearDataModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg p-6 w-full max-w-md">
            <div class="text-center">
                <div class="mb-4">
                    <div class="inline-block bg-red-100 rounded-full p-3">
                        <i class="fas fa-exclamation-triangle text-red-500 text-2xl"></i>
                    </div>
                </div>
                <h3 class="text-lg font-medium text-gray-900 mb-2">ç¡®è®¤æ¸…ç©ºæ‰€æœ‰æ•°æ®</h3>
                <div class="text-sm text-gray-600 mb-6">
                    æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤æ‰€æœ‰é‚®ç®±è´¦æˆ·ã€éªŒè¯ç å’Œæ¶ˆæ¯è®°å½•ï¼Œ<br>
                    åŒ…æ‹¬é‚®ç®±é…ç½®ã€éªŒè¯ç å†å²ã€å¯¼å…¥è®°å½•ç­‰æ‰€æœ‰æ•°æ®ã€‚<br><br>
                    <strong class="text-red-600">æ­¤æ“ä½œä¸å¯æ¢å¤ï¼</strong><br>
                    è¯·ç¡®è®¤æ‚¨çœŸçš„è¦ç»§ç»­å—ï¼Ÿ
                </div>

                <div class="mb-4">
                    <label class="flex items-center justify-center text-sm text-gray-700">
                        <input type="checkbox" id="confirmCheckbox" class="mr-2">
                        æˆ‘ç¡®è®¤è¦æ¸…ç©ºæ‰€æœ‰æ•°æ®ï¼Œå¹¶äº†è§£æ­¤æ“ä½œä¸å¯æ¢å¤
                    </label>
                </div>

                <div class="flex gap-3 justify-center">
                    <button onclick="hideClearDataModal()" class="px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition">
                        å–æ¶ˆ
                    </button>
                    <button
                        id="confirmClearButton"
                        onclick="clearAllData()"
                        disabled
                        class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition disabled:bg-gray-300 disabled:cursor-not-allowed"
                    >
                        <i class="fas fa-trash-alt mr-1"></i>ç¡®è®¤æ¸…ç©º
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ç›‘å¬ç¡®è®¤å¤é€‰æ¡†å˜åŒ–
        document.getElementById('confirmCheckbox').addEventListener('change', function() {
            const confirmButton = document.getElementById('confirmClearButton');
            confirmButton.disabled = !this.checked;
        });

        // é‚®ç®±åºåˆ—ç¼–å·ç®¡ç†å™¨ï¼ˆç§»æ¤è‡ªåŸç³»ç»Ÿï¼‰
        class EmailSequenceManager {
            constructor() {
                this.sequenceCache = new Map(); // ç¼“å­˜é‚®ç®±->ç¼–å·æ˜ å°„
                this.maxSequenceCache = 0; // ç¼“å­˜å½“å‰æœ€å¤§ç¼–å·
                this.initialized = false;
            }

            // åˆå§‹åŒ–åºåˆ—ç®¡ç†å™¨
            async initialize(accounts = []) {
                if (this.initialized) return;

                console.log('[EmailSequence] åˆå§‹åŒ–é‚®ç®±åºåˆ—ç®¡ç†å™¨...');

                // é¢„åŠ è½½ç°æœ‰é‚®ç®±çš„ç¼–å·æ˜ å°„
                this.loadExistingSequences(accounts);

                this.initialized = true;
                console.log(`[EmailSequence] åˆå§‹åŒ–å®Œæˆï¼Œå½“å‰æœ€å¤§ç¼–å·: ${this.maxSequenceCache}`);
            }

            // åŠ è½½ç°æœ‰åºåˆ—
            loadExistingSequences(accounts) {
                this.sequenceCache.clear();
                let maxSequence = 0;

                accounts.forEach(account => {
                    if (account.sequence && account.sequence > 0) {
                        const normalizedEmail = account.email.toLowerCase();
                        this.sequenceCache.set(normalizedEmail, account.sequence);
                        maxSequence = Math.max(maxSequence, account.sequence);
                    }
                });

                this.maxSequenceCache = maxSequence;
                console.log(`[EmailSequence] åŠ è½½äº† ${this.sequenceCache.size} ä¸ªé‚®ç®±ç¼–å·æ˜ å°„`);
            }

            // ä¸ºé‚®ç®±åˆ†é…åºåˆ—å·
            async assignSequence(email) {
                await this.initialize();

                const normalizedEmail = email.toLowerCase().trim();

                // æ£€æŸ¥ç¼“å­˜ä¸­æ˜¯å¦å·²æœ‰ç¼–å·
                if (this.sequenceCache.has(normalizedEmail)) {
                    const existingSequence = this.sequenceCache.get(normalizedEmail);
                    console.log(`[EmailSequence] é‚®ç®± ${email} ä½¿ç”¨ç°æœ‰ç¼–å·: ${existingSequence}`);
                    return existingSequence;
                }

                // åˆ†é…æ–°ç¼–å·
                const newSequence = this.maxSequenceCache + 1;

                // æ›´æ–°ç¼“å­˜
                this.sequenceCache.set(normalizedEmail, newSequence);
                this.maxSequenceCache = newSequence;

                console.log(`[EmailSequence] é‚®ç®± ${email} åˆ†é…æ–°ç¼–å·: ${newSequence}`);
                return newSequence;
            }

            // æ‰¹é‡åˆ†é…åºåˆ—å·
            async batchAssignSequences(emails) {
                await this.initialize();

                const result = new Map();
                const newAssignments = [];

                // ç¬¬ä¸€éï¼šæ£€æŸ¥å·²æœ‰ç¼–å·
                for (const email of emails) {
                    const normalizedEmail = email.toLowerCase().trim();

                    if (this.sequenceCache.has(normalizedEmail)) {
                        const existingSequence = this.sequenceCache.get(normalizedEmail);
                        result.set(email, existingSequence);
                    } else {
                        // éœ€è¦åˆ†é…æ–°ç¼–å·
                        newAssignments.push(email);
                    }
                }

                // ç¬¬äºŒéï¼šæ‰¹é‡åˆ†é…æ–°ç¼–å·
                if (newAssignments.length > 0) {
                    const startSequence = this.maxSequenceCache + 1;

                    for (let i = 0; i < newAssignments.length; i++) {
                        const email = newAssignments[i];
                        const newSequence = startSequence + i;
                        const normalizedEmail = email.toLowerCase().trim();

                        // ç›´æ¥æ›´æ–°ç¼“å­˜
                        this.sequenceCache.set(normalizedEmail, newSequence);
                        result.set(email, newSequence);
                    }

                    // æ›´æ–°æœ€å¤§ç¼–å·ç¼“å­˜
                    this.maxSequenceCache = startSequence + newAssignments.length - 1;

                    console.log(`[EmailSequence] æ‰¹é‡åˆ†é… ${newAssignments.length} ä¸ªæ–°ç¼–å·: ${startSequence}-${this.maxSequenceCache}`);
                }

                return result;
            }

            // è·å–é‚®ç®±çš„ç¼–å·
            getEmailSequence(email) {
                const normalizedEmail = email.toLowerCase().trim();
                return this.sequenceCache.get(normalizedEmail) || null;
            }

            // é‡å»ºç¼–å·åºåˆ—
            rebuildSequence(accounts) {
                console.log('[EmailSequence] å¼€å§‹é‡å»ºç¼–å·åºåˆ—...');

                this.sequenceCache.clear();
                let currentSequence = 0;

                // æŒ‰åˆ›å»ºæ—¶é—´æ’åºæ‰€æœ‰è´¦æˆ·
                const sortedAccounts = accounts.sort((a, b) =>
                    new Date(a.created_at) - new Date(b.created_at)
                );

                const seenEmails = new Set();

                for (const account of sortedAccounts) {
                    const normalizedEmail = account.email.toLowerCase().trim();

                    if (!seenEmails.has(normalizedEmail)) {
                        currentSequence++;
                        this.sequenceCache.set(normalizedEmail, currentSequence);
                        account.sequence = currentSequence; // ç›´æ¥æ›´æ–°è´¦æˆ·å¯¹è±¡çš„åºåˆ—å·
                        seenEmails.add(normalizedEmail);
                    }
                }

                this.maxSequenceCache = currentSequence;
                console.log(`[EmailSequence] é‡å»ºå®Œæˆï¼Œå¤„ç†äº† ${seenEmails.size} ä¸ªé‚®ç®±ï¼Œå½“å‰æœ€å¤§ç¼–å·: ${currentSequence}`);

                return currentSequence;
            }

            // è·å–ç¼–å·ç»Ÿè®¡ä¿¡æ¯
            getSequenceStats() {
                return {
                    total_accounts: this.sequenceCache.size,
                    max_sequence: this.maxSequenceCache,
                    next_sequence: this.maxSequenceCache + 1
                };
            }
        }

        // ç®€åŒ–çš„é‚®ä»¶ç®¡ç†å™¨ - éµå¾ªKISSåŸåˆ™
        class SimpleMailManager {
            constructor() {
                this.accounts = [];
                this.filteredAccounts = [];
                this.selectedAccounts = new Set(); // é€‰ä¸­çš„è´¦æˆ·IDé›†åˆ
                this.sortField = 'sequence';
                this.sortDirection = 'asc';
                this.currentPage = 1;
                this.pageSize = 50;

                // é‚®ä»¶åºåˆ—ç®¡ç†å™¨
                this.sequenceManager = new EmailSequenceManager();

                // SSEå®æ—¶æ›´æ–°ç³»ç»Ÿ
                this.eventSource = null;
                this.sseConnected = false;

                this.init();
            }

            async init() {
                await this.loadAccounts();
                await this.sequenceManager.initialize(this.accounts);

                // åˆå§‹åŒ–WebSocketé‡è¿ç›¸å…³å˜é‡
                this.wsConnected = false;
                this.wsReconnectAttempts = 0;
                this.wsReconnectTimer = null;

                // ä¼˜å…ˆå¯åŠ¨WebSocketå®æ—¶æ›´æ–°
                this.connectWebSocket();

                this.render();
                this.updateStats();
            }

            // WebSocketå®æ—¶æ›´æ–°ç³»ç»Ÿ - æ›¿ä»£SSEæä¾›æ›´ç¨³å®šçš„è¿æ¥
            connectWebSocket() {
                if (this.websocket) {
                    this.websocket.close();
                }

                // ä»localStorageè·å–æˆ–ç”Ÿæˆä¼šè¯ID
                if (!this.sessionId) {
                    const savedSessionId = localStorage.getItem('mail_manager_session_id');
                    if (savedSessionId) {
                        this.sessionId = savedSessionId;
                        console.log(`[WebSocket] æ¢å¤ä¼šè¯ID: ${this.sessionId}`);
                    } else {
                        this.sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        localStorage.setItem('mail_manager_session_id', this.sessionId);
                        console.log(`[WebSocket] ç”Ÿæˆå¹¶ä¿å­˜ä¼šè¯ID: ${this.sessionId}`);
                    }
                }

                try {
                    console.log('[WebSocket] æ­£åœ¨è¿æ¥å®æ—¶æ›´æ–°æœåŠ¡...');
                    // è¿æ¥ç­–ç•¥ï¼šä¼˜å…ˆä»£ç†è¿æ¥ï¼Œå¤‡ç”¨ç›´è¿
                    let wsUrl;
                    if (window.location.protocol === 'https:') {
                        // HTTPSç¯å¢ƒï¼Œä½¿ç”¨wss
                        wsUrl = `wss://${window.location.host}/ws?sessionId=${encodeURIComponent(this.sessionId)}`;
                    } else if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                        // æœ¬åœ°å¼€å‘ç¯å¢ƒï¼Œç›´è¿WebSocketç«¯å£
                        wsUrl = `ws://localhost:3002?sessionId=${encodeURIComponent(this.sessionId)}`;
                    } else {
                        // ç”Ÿäº§ç¯å¢ƒï¼Œä½¿ç”¨ä»£ç†è¿æ¥
                        wsUrl = `ws://${window.location.host}/ws?sessionId=${encodeURIComponent(this.sessionId)}`;
                    }

                    console.log(`[WebSocket] è¿æ¥URL: ${wsUrl}`);
                    this.websocket = new WebSocket(wsUrl);

                    this.websocket.onopen = () => {
                        console.log('[WebSocket] å®æ—¶æ›´æ–°è¿æ¥æˆåŠŸ');
                        this.wsConnected = true;
                        this.showNotification('å·²è¿æ¥åˆ°WebSocketå®æ—¶æ›´æ–°æœåŠ¡', 'success');

                        // è®¢é˜…æ‰€æœ‰äº‹ä»¶ç±»å‹ï¼ŒåŒ…å«sessionId
                        this.websocket.send(JSON.stringify({
                            type: 'subscribe',
                            sessionId: this.sessionId,
                            events: [
                                'verification_code_found',
                                'account_status_changed',
                                'manual_fetch_complete',
                                'manual_fetch_error',
                                'bulk_import_progress',
                                'import_progress',
                                'monitoring_started',
                                'monitoring_ended'
                            ]
                        }));
                    };

                    this.websocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleWebSocketEvent(data);
                        } catch (error) {
                            console.error('[WebSocket] è§£æäº‹ä»¶æ•°æ®å¤±è´¥:', error);
                        }
                    };

                    this.websocket.onerror = (error) => {
                        console.error('[WebSocket] è¿æ¥é”™è¯¯:', error);
                        this.wsConnected = false;
                        this.attemptWebSocketReconnect();
                    };

                    this.websocket.onclose = (event) => {
                        console.log(`[WebSocket] è¿æ¥å…³é—­: ${event.code} - ${event.reason}`);
                        this.wsConnected = false;
                        this.attemptWebSocketReconnect();
                    };

                } catch (error) {
                    console.error('[WebSocket] è¿æ¥å¤±è´¥:', error);
                    this.showNotification('æ— æ³•è¿æ¥WebSocketå®æ—¶æœåŠ¡ï¼Œå°è¯•SSEå¤‡ç”¨æ–¹æ¡ˆ', 'warning');
                    this.connectSSE(); // å¤‡ç”¨SSEè¿æ¥
                }
            }

            // WebSocketé‡è¿æœºåˆ¶
            attemptWebSocketReconnect() {
                if (this.wsReconnectTimer) {
                    clearTimeout(this.wsReconnectTimer);
                }

                const reconnectDelay = Math.min(1000 * Math.pow(2, this.wsReconnectAttempts), 30000);
                this.wsReconnectAttempts++;

                console.log(`[WebSocket] ${reconnectDelay/1000}ç§’åå°è¯•ç¬¬${this.wsReconnectAttempts}æ¬¡é‡è¿...`);

                this.wsReconnectTimer = setTimeout(() => {
                    if (!this.wsConnected) {
                        this.connectWebSocket();
                    }
                }, reconnectDelay);
            }

            // å¤„ç†WebSocketäº‹ä»¶
            handleWebSocketEvent(data) {
                console.log('[WebSocket] æ”¶åˆ°äº‹ä»¶:', data);
                console.log('[WebSocket] äº‹ä»¶ç±»å‹:', data.type);

                switch (data.type) {
                    case 'connection_established':
                        console.log(`[WebSocket] è¿æ¥ç¡®è®¤: ${data.clientId}`);
                        this.wsReconnectAttempts = 0; // é‡ç½®é‡è¿è®¡æ•°
                        break;

                    case 'ping':
                        // å“åº”å¿ƒè·³
                        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                            this.websocket.send(JSON.stringify({
                                type: 'pong',
                                timestamp: new Date().toISOString()
                            }));
                        }
                        break;

                    case 'verification_code_found':
                        this.handleVerificationCodeFound(data);
                        break;

                    case 'account_status_changed':
                        this.handleAccountStatusChanged(data);
                        break;

                    case 'manual_fetch_complete':
                        this.handleManualFetchComplete(data);
                        break;

                    case 'manual_fetch_error':
                        this.handleManualFetchError(data);
                        break;

                    case 'bulk_import_progress':
                        this.handleBulkImportProgress(data);
                        break;

                    case 'import_progress':
                        this.handleImportProgress(data);
                        break;

                    default:
                        console.log(`[WebSocket] æœªçŸ¥äº‹ä»¶ç±»å‹: ${data.type}`);
                }
            }

            // è¿æ¥SSEå®æ—¶æ›´æ–°ç³»ç»Ÿï¼ˆWebSocketå¤‡ç”¨æ–¹æ¡ˆï¼‰
            connectSSE() {
                if (this.eventSource) {
                    this.eventSource.close();
                }

                // ä»localStorageè·å–æˆ–ç”Ÿæˆä¼šè¯ID
                if (!this.sessionId) {
                    const savedSessionId = localStorage.getItem('mail_manager_session_id');
                    if (savedSessionId) {
                        this.sessionId = savedSessionId;
                        console.log(`[SSE] æ¢å¤ä¼šè¯ID: ${this.sessionId}`);
                    } else {
                        this.sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        localStorage.setItem('mail_manager_session_id', this.sessionId);
                        console.log(`[SSE] ç”Ÿæˆå¹¶ä¿å­˜ä¼šè¯ID: ${this.sessionId}`);
                    }
                }

                try {
                    console.log('[SSE] æ­£åœ¨è¿æ¥å®æ—¶æ›´æ–°æœåŠ¡...');
                    this.eventSource = new EventSource(`/api/events/stream/${this.sessionId}`);

                    this.eventSource.onopen = () => {
                        console.log('[SSE] å®æ—¶æ›´æ–°è¿æ¥æˆåŠŸ');
                        this.sseConnected = true;
                        this.showNotification('å·²è¿æ¥åˆ°å®æ—¶æ›´æ–°æœåŠ¡', 'success');
                    };

                    this.eventSource.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleSSEEvent(data);
                        } catch (error) {
                            console.error('[SSE] è§£æäº‹ä»¶æ•°æ®å¤±è´¥:', error);
                        }
                    };

                    this.eventSource.onerror = () => this.reconnectSSE();

                } catch (error) {
                    console.error('[SSE] è¿æ¥å¤±è´¥:', error);
                    this.showNotification('æ— æ³•è¿æ¥å®æ—¶æ›´æ–°æœåŠ¡', 'error');
                }
            }

            // å¤„ç†SSEäº‹ä»¶
            handleSSEEvent(data) {
                console.log('[SSE] æ”¶åˆ°äº‹ä»¶:', data);
                console.log('[SSE] äº‹ä»¶ç±»å‹:', data.type);
                console.log('[SSE] å½“å‰ä¼šè¯ID:', this.sessionId);

                switch (data.type) {
                    case 'connection':
                        console.log(`[SSE] è¿æ¥ç¡®è®¤: ${data.message}`);
                        break;

                    case 'heartbeat':
                        // å¿ƒè·³äº‹ä»¶ï¼Œæ— éœ€å¤„ç†
                        break;

                    case 'monitoring_started':
                        this.handleMonitoringStarted(data);
                        break;

                    case 'monitoring_progress':
                        this.handleMonitoringProgress(data);
                        break;

                    case 'monitoring_ended':
                        this.handleMonitoringEnded(data);
                        break;

                    case 'monitoring_error':
                        this.handleMonitoringError(data);
                        break;

                    case 'verification_code_found':
                        this.handleVerificationCodeFound(data);
                        break;

                    case 'account_status_changed':
                        this.handleAccountStatusChanged(data);
                        break;

                    case 'manual_fetch_complete':
                        this.handleManualFetchComplete(data);
                        break;

                    case 'manual_fetch_error':
                        this.handleManualFetchError(data);
                        break;

                    case 'bulk_import_progress':
                        this.handleBulkImportProgress(data);
                        break;

                    case 'import_progress':
                        this.handleImportProgress(data);
                        break;

                    default:
                        console.log(`[SSE] æœªçŸ¥äº‹ä»¶ç±»å‹: ${data.type}`);
                }
            }

            // å¤„ç†ç›‘æ§å¼€å§‹äº‹ä»¶
            handleMonitoringStarted(data) {
                const account = this.accounts.find(acc => acc.id === data.account_id);
                if (account) {
                    account.is_monitoring = true;
                    this.saveAccounts();
                    this.render();
                    this.updateStats();

                    this.showNotification(data.message, 'info');
                }
            }

            // å¤„ç†ç›‘æ§è¿›åº¦äº‹ä»¶
            handleMonitoringProgress(data) {
                console.log('[SSE] ç›‘æ§è¿›åº¦:', data);
                this.showNotification(data.message, 'info');
            }

            // å¤„ç†ç›‘æ§ç»“æŸäº‹ä»¶
            handleMonitoringEnded(data) {
                console.log('[SSE] ç›‘æ§ç»“æŸ:', data);

                // æ›´æ–°è´¦æˆ·ç›‘æ§çŠ¶æ€
                const account = this.accounts.find(acc => acc.id === data.account_id);
                if (account) {
                    account.is_monitoring = false;
                    // ç›‘æ§ç»“æŸæ—¶æ¸…é™¤åªæ˜¾ç¤ºç›‘æ§éªŒè¯ç çš„æ ‡è®°
                    if (account.monitoring_codes_only) {
                        account.monitoring_codes_only = false;
                        console.log(`[ç›‘æ§ç»“æŸ] è´¦æˆ· ${account.email} æ¸…é™¤ç›‘æ§æ ‡è®°ï¼Œç°åœ¨æ˜¾ç¤ºæ‰€æœ‰éªŒè¯ç `);
                    }
                    this.saveAccounts();
                    this.updateStats();
                    this.render();
                }

                this.showNotification(data.message, 'success');
            }

            // å¤„ç†ç›‘æ§é”™è¯¯äº‹ä»¶
            handleMonitoringError(data) {
                console.error('[SSE] ç›‘æ§é”™è¯¯:', data);

                // æ›´æ–°è´¦æˆ·ç›‘æ§çŠ¶æ€
                const account = this.accounts.find(acc => acc.id === data.account_id);
                if (account) {
                    account.is_monitoring = false;
                    this.saveAccounts();
                    this.updateStats();
                    this.render();
                }

                this.showError(data.message);
            }

            // å¤„ç†å‘ç°éªŒè¯ç äº‹ä»¶
            handleVerificationCodeFound(data) {
                console.log('[SSE] æ”¶åˆ°éªŒè¯ç äº‹ä»¶:', data);
                const account = this.accounts.find(acc => acc.id === data.account_id);
                if (account) {
                    console.log('[SSE] æ‰¾åˆ°è´¦æˆ·:', account.email, 'å½“å‰éªŒè¯ç æ•°é‡:', account.codes?.length || 0);

                    account.codes.unshift({
                        code: data.code,
                        sender: data.sender,
                        received_at: data.received_at,
                        score: data.score || 1.0
                    });

                    // ä¿æŒæœ€å¤š10ä¸ªéªŒè¯ç 
                    if (account.codes.length > 10) {
                        account.codes = account.codes.slice(0, 10);
                    }

                    account.updated_at = new Date().toISOString();
                    this.saveAccounts();
                    this.updateStats();

                    // æ ‡è®°æ–°éªŒè¯ç ï¼Œè§¦å‘10ç§’è“è‰²èƒŒæ™¯æé†’ï¼ˆåŒ…å«æ¸²æŸ“ï¼‰
                    this.markNewVerificationCode(data.account_id);

                    this.showNotification(`æ”¶åˆ°æ–°éªŒè¯ç : ${data.code} (${data.sender})`, 'success');
                    console.log('[SSE] éªŒè¯ç å·²æ›´æ–°åˆ°è´¦æˆ·ï¼Œé‡æ–°æ¸²æŸ“å®Œæˆ');
                } else {
                    console.log('[SSE] æœªæ‰¾åˆ°è´¦æˆ·ï¼ŒID:', data.account_id);
                }
            }

            // å¤„ç†è´¦æˆ·çŠ¶æ€å˜åŒ–äº‹ä»¶
            handleAccountStatusChanged(data) {
                const account = this.accounts.find(acc => acc.id === data.account_id);
                if (account) {
                    account.status = data.status;
                    account.updated_at = new Date().toISOString();

                    // KISS ä¼˜åŒ–ï¼šæ›´æ–°tokenä¿¡æ¯ç¡®ä¿æŒä¹…åŒ–
                    if (data.access_token) {
                        account.access_token = data.access_token;
                    }
                    if (data.refresh_token) {
                        account.refresh_token = data.refresh_token;
                    }

                    // æ›´æ–°æœ€åæ£€æŸ¥æ—¶é—´ï¼Œç”¨äºæ–°é‚®ä»¶è¿‡æ»¤
                    account.last_check = new Date().toISOString();

                    this.saveAccounts();
                    this.render();
                    this.updateStats();

                    const statusMessages = {
                        'authorized': 'è´¦æˆ·æˆæƒæˆåŠŸ',
                        'reauth_needed': 'è´¦æˆ·éœ€è¦é‡æ–°æˆæƒ',
                        'error': 'è´¦æˆ·æˆæƒå¤±è´¥'
                    };

                    const message = statusMessages[data.new_status] || `è´¦æˆ·çŠ¶æ€æ›´æ–°ä¸º: ${data.new_status}`;
                    this.showNotification(`${account.email}: ${message}`, data.new_status === 'authorized' ? 'success' : 'warning');

                    // æˆæƒæˆåŠŸåè‡ªåŠ¨è§¦å‘å–ä»¶å’ŒéªŒè¯ç æå–
                    if (data.status === 'authorized' || data.new_status === 'authorized') {
                        console.log(`[è‡ªåŠ¨å–ä»¶] è´¦æˆ· ${account.email} æˆæƒæˆåŠŸï¼Œå¼€å§‹è‡ªåŠ¨å–ä»¶`);
                        setTimeout(() => {
                            this.autoFetchEmails(account.id);
                        }, 1000); // å»¶è¿Ÿ1ç§’ç¡®ä¿çŠ¶æ€æ›´æ–°å®Œæˆ
                    }
                }
            }

            // è‡ªåŠ¨å–ä»¶å’ŒéªŒè¯ç æå–æ–¹æ³•ï¼ˆæˆæƒæˆåŠŸåè°ƒç”¨ï¼‰
            async autoFetchEmails(accountId) {
                const account = this.accounts.find(acc => acc.id === accountId);
                if (!account) {
                    console.error(`[è‡ªåŠ¨å–ä»¶] è´¦æˆ·ä¸å­˜åœ¨: ${accountId}`);
                    return;
                }

                console.log(`[è‡ªåŠ¨å–ä»¶] å¼€å§‹ä¸ºè´¦æˆ· ${account.email} è‡ªåŠ¨å–ä»¶`);

                try {
                    // ç¡®ä¿sessionIdå­˜åœ¨
                    if (!this.sessionId) {
                        const savedSessionId = localStorage.getItem('mail_manager_session_id');
                        if (savedSessionId) {
                            this.sessionId = savedSessionId;
                        } else {
                            this.sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                            localStorage.setItem('mail_manager_session_id', this.sessionId);
                        }
                    }

                    const requestData = {
                        account_id: accountId,
                        email: account.email,
                        client_id: account.client_id,
                        refresh_token: account.refresh_token,
                        access_token: account.access_token,
                        current_status: account.status,
                        sessionId: this.sessionId
                    };

                    console.log(`[è‡ªåŠ¨å–ä»¶] å‘é€å–ä»¶è¯·æ±‚:`, requestData);

                    const response = await fetch('/api/manual-fetch-emails', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestData)
                    });

                    const result = await response.json();
                    if (!response.ok) {
                        throw new Error(result.details || result.message || 'è‡ªåŠ¨å–ä»¶å¤±è´¥');
                    }

                    console.log(`[è‡ªåŠ¨å–ä»¶] ${account.email} å–ä»¶è¯·æ±‚å·²å‘é€`);
                    this.showNotification(`å·²è‡ªåŠ¨å¯åŠ¨ ${account.email} çš„é‚®ä»¶æ”¶å–...`, 'info');

                } catch (error) {
                    console.error(`[è‡ªåŠ¨å–ä»¶] ${account.email} å–ä»¶å¤±è´¥:`, error);
                    this.showError(`è‡ªåŠ¨å–ä»¶å¤±è´¥: ${error.message}`);
                }
            }

            // å¤„ç†æ‰‹åŠ¨å–ä»¶å®Œæˆäº‹ä»¶
            handleManualFetchComplete(data) {
                const account = this.accounts.find(acc => acc.id === data.account_id);
                if (account) {
                    // æ›´æ–°è´¦æˆ·æœ€åæ£€æŸ¥æ—¶é—´
                    account.last_check = new Date().toISOString();

                    // å¦‚æœæœ‰éªŒè¯ç æ‰¾åˆ°ï¼Œä¹Ÿæ›´æ–°éªŒè¯ç ä¿¡æ¯
                    if (data.verification_codes && data.verification_codes.length > 0) {
                        if (!account.verification_codes) {
                            account.verification_codes = [];
                        }

                        // æ·»åŠ æ–°çš„éªŒè¯ç åˆ°å†å²è®°å½•
                        data.verification_codes.forEach(code => {
                            account.verification_codes.unshift({
                                code: code.code,
                                sender: code.sender,
                                received_at: code.received_at,
                                created_at: new Date().toISOString()
                            });
                        });

                        // æœ€å¤šä¿ç•™10ä¸ªå†å²éªŒè¯ç 
                        if (account.verification_codes.length > 10) {
                            account.verification_codes = account.verification_codes.slice(0, 10);
                        }
                    }

                    this.saveAccounts();
                    this.render();
                    this.updateStats();

                    // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                    const message = data.message || 'é‚®ä»¶æ”¶å–å®Œæˆ';
                    this.showNotification(`${account.email}: ${message}`, 'success');
                }
            }

            // å¤„ç†æ‰‹åŠ¨å–ä»¶é”™ï¿½ï¿½äº‹ä»¶
            handleManualFetchError(data) {
                const account = this.accounts.find(acc => acc.id === data.account_id);
                if (account) {
                    const errorMessage = data.error || 'æ”¶å–å¤±è´¥';
                    this.showNotification(`${account.email}: ${errorMessage}`, 'error');
                }
            }

            // å¤„ç†æ‰¹é‡å¯¼å…¥è¿›åº¦äº‹ä»¶
            handleBulkImportProgress(data) {
                if (data.message) {
                    console.log(`[Import] ${data.message}`);
                }
            }

            // å¤„ç†å¼‚æ­¥å¯¼å…¥è¿›åº¦äº‹ä»¶
            handleImportProgress(data) {
                if (data.message) {
                    console.log(`[å¼‚æ­¥å¯¼å…¥] ${data.message}`);
                }
                // æ›´æ–°è¿›åº¦æ¡ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                if (data.processed !== undefined && data.total) {
                    const percentage = Math.round((data.processed / data.total) * 100);
                    console.log(`[å¼‚æ­¥å¯¼å…¥] è¿›åº¦: ${percentage}% (${data.processed}/${data.total})`);
                }
            }

            // ç®€åŒ–çš„SSEé‡è¿æœºåˆ¶
            reconnectSSE() {
                console.log('[SSE] å¯åŠ¨é‡è¿æœºåˆ¶');
                this.sseConnected = false;
                this.showNotification('å®æ—¶æ›´æ–°è¿æ¥æ–­å¼€ï¼Œå°è¯•é‡è¿...', 'warning');

                // æ¸…ç†ç°æœ‰è¿æ¥
                if (this.eventSource) {
                    this.eventSource.close();
                    this.eventSource = null;
                }

                // å»¶è¿Ÿé‡è¿
                setTimeout(() => {
                    if (!this.sseConnected) {
                        this.connectSSE();
                    }
                }, 5000);
            }

            // æ–­å¼€SSEè¿æ¥
            disconnectSSE() {
                if (this.eventSource) {
                    this.eventSource.close();
                    this.eventSource = null;
                    this.sseConnected = false;
                    console.log('[SSE] å®æ—¶æ›´æ–°è¿æ¥å·²æ–­å¼€');
                }
            }

            // æ˜¾ç¤ºé€šçŸ¥æ¶ˆæ¯
            showNotification(message, type = 'info') {
                // åˆ›å»ºé€šçŸ¥å…ƒç´ 
                const notification = document.createElement('div');
                notification.className = `notification notification-${type} fixed top-4 right-4 px-4 py-3 rounded-lg shadow-lg z-50 transform transition-all duration-300 translate-x-full`;

                // æ ¹æ®ç±»å‹è®¾ç½®æ ·å¼
                const typeStyles = {
                    'success': 'bg-green-500 text-white',
                    'error': 'bg-red-500 text-white',
                    'warning': 'bg-yellow-500 text-white',
                    'info': 'bg-blue-500 text-white'
                };

                notification.className += ' ' + (typeStyles[type] || typeStyles.info);

                // è®¾ç½®é€šçŸ¥å†…å®¹
                notification.innerHTML = `
                    <div class="flex items-center gap-2">
                        <i class="fas fa-${this.getNotificationIcon(type)}"></i>
                        <span>${message}</span>
                        <button onclick="this.parentElement.parentElement.remove()" class="ml-4 hover:opacity-75">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;

                // æ·»åŠ åˆ°é¡µé¢
                document.body.appendChild(notification);

                // åŠ¨ç”»æ˜¾ç¤º
                setTimeout(() => {
                    notification.classList.remove('translate-x-full');
                    notification.classList.add('translate-x-0');
                }, 100);

                // è‡ªåŠ¨ç§»é™¤
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.classList.remove('translate-x-0');
                        notification.classList.add('translate-x-full');
                        setTimeout(() => {
                            if (notification.parentElement) {
                                notification.remove();
                            }
                        }, 300);
                    }
                }, 5000);
            }

            // è·å–é€šçŸ¥å›¾æ ‡
            getNotificationIcon(type) {
                const icons = {
                    'success': 'check-circle',
                    'error': 'exclamation-circle',
                    'warning': 'exclamation-triangle',
                    'info': 'info-circle'
                };
                return icons[type] || icons.info;
            }

            // ä¾¿æ·æ–¹æ³•
            showSuccess(message) {
                this.showNotification(message, 'success');
            }

            showError(message) {
                this.showNotification(message, 'error');
            }

            // å­˜å‚¨æ“ä½œ - ä½¿ç”¨ç®€å•çš„LocalStorage
            saveAccounts() {
                localStorage.setItem('mailmanager_accounts', JSON.stringify(this.accounts));
            }

            async loadAccounts() {
                const stored = localStorage.getItem('mailmanager_accounts');
                this.accounts = stored ? JSON.parse(stored) : [];
                this.filteredAccounts = [...this.accounts];

                // ç¡®ä¿æ‰€æœ‰è´¦æˆ·éƒ½æœ‰åºåˆ—å·ï¼ˆå¦‚æœæ²¡æœ‰åˆ™åˆ†é…ï¼‰
                for (const account of this.accounts) {
                    if (!account.sequence) {
                        account.sequence = await this.sequenceManager.assignSequence(account.email);
                    }
                }
            }

            // è´¦æˆ·æ“ä½œ
            async addAccount(email, name, clientId, refreshToken) {
                // è°ƒè¯•ï¼šè®°å½•ä¼ å…¥çš„å‚æ•°
                console.log(`[AddAccount Debug] ä¼ å…¥å‚æ•°:`, {
                    email,
                    name,
                    hasClientId: !!clientId,
                    clientIdLength: clientId ? clientId.length : 0,
                    hasRefreshToken: !!refreshToken,
                    refreshTokenLength: refreshToken ? refreshToken.length : 0
                });

                // åˆ†é…åºåˆ—å·
                const sequence = await this.sequenceManager.assignSequence(email);

                const account = {
                    id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 5),
                    email: email,
                    name: name || email,
                    client_id: clientId,
                    refresh_token: refreshToken,
                    status: 'pending',
                    codes: [],
                    sequence: sequence,
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                    last_active_at: new Date().toISOString(),
                    access_token: null,
                    token_expires_at: null,
                    is_monitoring: false,
                    authorization_status: 'pending' // æ–°å¢æˆæƒçŠ¶æ€å­—æ®µ
                };

                // è°ƒè¯•ï¼šè®°å½•åˆ›å»ºçš„è´¦æˆ·å¯¹è±¡
                console.log(`[AddAccount Debug] åˆ›å»ºçš„è´¦æˆ·:`, {
                    id: account.id,
                    email: account.email,
                    hasClientId: !!account.client_id,
                    clientIdLength: account.client_id ? account.client_id.length : 0,
                    hasRefreshToken: !!account.refresh_token,
                    refreshTokenLength: account.refresh_token ? account.refresh_token.length : 0,
                    accountKeys: Object.keys(account)
                });

                this.accounts.push(account);
                this.filteredAccounts = [...this.accounts];
                this.saveAccounts();
                return account;
            }

            // æ›´æ–°è´¦æˆ·çŠ¶æ€ï¼ˆå®Œæ•´çš„çŠ¶æ€ç®¡ç†ï¼‰
            updateAccountStatus(accountId, status, extraData = {}) {
                const account = this.accounts.find(acc => acc.id === accountId);
                if (!account) return false;

                const oldStatus = account.status;
                account.status = status;
                account.updated_at = new Date().toISOString();

                // çŠ¶æ€è½¬æ¢æ—¶çš„ç‰¹æ®Šå¤„ç†
                switch (status) {
                    case 'authorized':
                        account.last_active_at = new Date().toISOString();
                        account.authorization_status = 'active';
                        break;
                    case 'reauth_needed':
                        account.authorization_status = 'expired';
                        break;
                    case 'reauth_failed':
                        account.authorization_status = 'failed';
                        break;
                    case 'error':
                        account.authorization_status = 'error';
                        break;
                    case 'pending':
                        account.authorization_status = 'pending';
                        break;
                }

                // åˆå¹¶é¢å¤–æ•°æ®
                Object.assign(account, extraData);

                this.saveAccounts();
                console.log(`[Status] è´¦æˆ· ${account.email} çŠ¶æ€æ›´æ–°: ${oldStatus} â†’ ${status}`);
                return true;
            }

            // æ£€æŸ¥è´¦æˆ·çŠ¶æ€
            checkAccountStatus(account) {
                if (!account) return 'unknown';

                // æ£€æŸ¥tokenè¿‡æœŸ
                if (account.access_token && account.token_expires_at) {
                    const expiresAt = new Date(account.token_expires_at);
                    const now = new Date();
                    if (now >= expiresAt) {
                        return 'reauth_needed';
                    }
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰å¿…è¦çš„è®¤è¯ä¿¡æ¯
                if (!account.client_id || !account.refresh_token) {
                    return 'reauth_needed';
                }

                return account.status;
            }

            // æ‰¹é‡æ£€æŸ¥è´¦æˆ·çŠ¶æ€
            async batchCheckAccountStatus(accountIds = null) {
                const accountsToCheck = accountIds
                    ? this.accounts.filter(acc => accountIds.includes(acc.id))
                    : this.accounts;

                const statusUpdates = [];

                for (const account of accountsToCheck) {
                    const newStatus = this.checkAccountStatus(account);
                    if (newStatus !== account.status) {
                        statusUpdates.push({
                            accountId: account.id,
                            email: account.email,
                            oldStatus: account.status,
                            newStatus: newStatus
                        });

                        this.updateAccountStatus(account.id, newStatus);
                    }
                }

                if (statusUpdates.length > 0) {
                    console.log(`[StatusCheck] æ‰¹é‡æ£€æŸ¥å®Œæˆï¼Œæ›´æ–°äº† ${statusUpdates.length} ä¸ªè´¦æˆ·çŠ¶æ€`);
                    this.render();
                    this.updateStats();
                }

                return statusUpdates;
            }

            // è·å–éœ€è¦é‡æ–°æˆæƒçš„è´¦æˆ·
            getReauthNeededAccounts() {
                return this.accounts.filter(account => {
                    const status = this.checkAccountStatus(account);
                    return status === 'reauth_needed' || status === 'reauth_failed';
                });
            }

            // éªŒè¯è´¦æˆ·æˆæƒçŠ¶æ€
            async validateAccountAuthorization(accountId) {
                const account = this.accounts.find(acc => acc.id === accountId);
                if (!account) return false;

                try {
                    // ä½¿ç”¨refresh tokenéªŒè¯
                    const authResult = await this.validateAccountAuth(accountId);

                    if (authResult && authResult.success) {
                        this.updateAccountStatus(accountId, 'authorized', {
                            last_active_at: new Date().toISOString()
                        });
                        return true;
                    } else {
                        this.updateAccountStatus(accountId, 'reauth_needed');
                        return false;
                    }
                } catch (error) {
                    console.error(`[Auth] éªŒè¯è´¦æˆ· ${account.email} æˆæƒå¤±è´¥:`, error);
                    this.updateAccountStatus(accountId, 'error');
                    return false;
                }
            }

            // é‡ç½®è´¦æˆ·çŠ¶æ€
            resetAccountStatus(accountId) {
                const account = this.accounts.find(acc => acc.id === accountId);
                if (!account) return false;

                // æ¸…é™¤è®¤è¯ç›¸å…³å­—æ®µ
                account.access_token = null;
                account.token_expires_at = null;
                account.is_monitoring = false;

                // é‡ç½®çŠ¶æ€
                this.updateAccountStatus(accountId, 'pending');

                return true;
            }

            deleteAccount(id) {
                this.accounts = this.accounts.filter(acc => acc.id !== id);
                this.filteredAccounts = [...this.accounts];
                this.saveAccounts();
            }

            updateAccountStatus(id, status) {
                const account = this.accounts.find(acc => acc.id === id);
                if (account) {
                    account.status = status;
                    account.updated_at = new Date().toISOString();
                    this.saveAccounts();
                }
            }

            addCode(accountId, code, sender, received_at = null) {
                const account = this.accounts.find(acc => acc.id === accountId);
                if (account) {
                    account.codes.unshift({
                        code: code,
                        sender: sender,
                        received_at: received_at || new Date().toISOString()
                    });

                    // åªä¿ç•™æœ€æ–°10ä¸ªéªŒè¯ç 
                    if (account.codes.length > 10) {
                        account.codes = account.codes.slice(0, 10);
                    }

                    account.updated_at = new Date().toISOString();
                    this.saveAccounts();
                }
            }

            // ç›´æ¥éªŒè¯è´¦æˆ·æˆæƒï¼ˆä½¿ç”¨refresh tokenï¼Œæ— éœ€OAuthå¼¹çª—ï¼‰
            async validateAccountAuth(accountId) {
                const account = this.accounts.find(acc => acc.id === accountId);

                // è¯¦ç»†è°ƒè¯•ä¿¡æ¯
                console.log(`[Auth Debug] éªŒè¯è´¦æˆ·æˆæƒ:`, {
                    accountId,
                    accountExists: !!account,
                    hasClientId: account ? !!account.client_id : false,
                    hasRefreshToken: account ? !!account.refresh_token : false,
                    clientIdLength: account && account.client_id ? account.client_id.length : 0,
                    refreshTokenLength: account && account.refresh_token ? account.refresh_token.length : 0,
                    accountKeys: account ? Object.keys(account) : []
                });

                if (!account || !account.client_id || !account.refresh_token) {
                    const missingInfo = [];
                    if (!account) missingInfo.push('è´¦æˆ·å¯¹è±¡');
                    if (account && !account.client_id) missingInfo.push('client_id');
                    if (account && !account.refresh_token) missingInfo.push('refresh_token');

                    console.error(`[Auth Error] è´¦æˆ·ç¼ºå°‘å¿…è¦çš„æˆæƒä¿¡æ¯:`, {
                        accountId,
                        missing: missingInfo,
                        account: account ? {
                            id: account.id,
                            email: account.email,
                            hasClientId: !!account.client_id,
                            hasRefreshToken: !!account.refresh_token,
                            clientIdLength: account.client_id ? account.client_id.length : 0,
                            refreshTokenLength: account.refresh_token ? account.refresh_token.length : 0,
                            accountKeys: Object.keys(account)
                        } : null
                    });

                    // æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                    const errorMessage = `è´¦æˆ· ${account?.email || accountId} ç¼ºå°‘å¿…è¦çš„æˆæƒä¿¡æ¯: ${missingInfo.join(', ')}`;
                    alert(errorMessage);
                    return;
                }

                try {
                    console.log('æ­£åœ¨éªŒè¯è´¦æˆ·æˆæƒ:', account.email);

                    // ä½¿ç”¨ä»£ç†æœåŠ¡å™¨è°ƒç”¨Microsoft tokenåˆ·æ–°ç«¯ç‚¹
                    const PROXY_URL = '/api/microsoft/token';
                    const response = await fetch(PROXY_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: account.client_id,
                            refresh_token: account.refresh_token,
                            grant_type: 'refresh_token',
                            scope: 'https://outlook.office.com/Mail.Read'
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        const accessToken = data.access_token;
                        const expiresIn = data.expires_in || 3600;

                        // æ›´æ–°è´¦æˆ·çŠ¶æ€å’Œtoken
                        account.access_token = accessToken;
                        account.token_expires_at = new Date(Date.now() + expiresIn * 1000).toISOString();
                        this.updateAccountStatus(accountId, 'authorized');

                        console.log('è´¦æˆ·æˆæƒéªŒè¯æˆåŠŸï¼', account.email);

                        // è‡ªåŠ¨å¼€å§‹é‚®ä»¶åŒæ­¥
                        setTimeout(() => {
                            this.syncAccountEmails(accountId);
                        }, 1000);

                        return { success: true, access_token: accessToken };

                    } else {
                        const errorData = await response.text();
                        console.error('TokenéªŒè¯å¤±è´¥:', response.status, errorData);
                        this.updateAccountStatus(accountId, 'reauth_needed');

                        return { success: false, error: `HTTP ${response.status}` };
                    }

                } catch (error) {
                    console.error('éªŒè¯è´¦æˆ·æˆæƒå¤±è´¥:', error);
                    this.updateAccountStatus(accountId, 'reauth_needed');

                    // ä¸æ˜¾ç¤ºalertï¼Œè®©è°ƒç”¨æ–¹å¤„ç†é”™è¯¯
                    if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        // ç½‘ç»œé”™è¯¯ï¼Œä¸æŠ›å‡ºå¼‚å¸¸
                        console.warn('ç½‘ç»œé”™è¯¯ï¼Œè·³è¿‡æˆæƒéªŒè¯');
                        return { success: false, error: 'Network error', networkError: true };
                    }

                    return { success: false, error: error.message };
                }
            }

            // åŒæ­¥è´¦æˆ·é‚®ä»¶
            async syncAccountEmails(accountId) {
                const account = this.accounts.find(acc => acc.id === accountId);
                if (!account || !account.access_token) {
                    console.error('è´¦æˆ·ç¼ºå°‘è®¿é—®ä»¤ç‰Œ');
                    return;
                }

                try {
                    console.log('æ­£åœ¨åŒæ­¥é‚®ä»¶:', account.email);

                    // ä½¿ç”¨ä»£ç†æœåŠ¡å™¨è°ƒç”¨Outlook API
                    const PROXY_URL = '/api/outlook/api/v2.0/me/messages?$orderby=ReceivedDateTime desc&$top=5';
                    const response = await fetch(PROXY_URL, {
                        headers: {
                            'Authorization': `Bearer ${account.access_token}`,
                            'Content-Type': 'application/json',
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`Outlook APIè°ƒç”¨å¤±è´¥: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();
                    const messages = data.value || [];

                    // ä¿å­˜é‚®ä»¶åˆ°è´¦æˆ·çš„emailsæ•°ç»„ä¸­ï¼ˆæµè§ˆå™¨ç¼“å­˜ï¼‰
                    if (!account.emails) {
                        account.emails = [];
                    }

                    // å¤„ç†æ–°é‚®ä»¶ï¼Œé¿å…é‡å¤
                    const existingEmailIds = new Set(account.emails.map(email => email.id));
                    let newEmailCount = 0;

                    messages.forEach(message => {
                        if (!existingEmailIds.has(message.id)) {
                            account.emails.push({
                                id: message.id,
                                subject: message.subject || 'æ— æ ‡é¢˜',
                                from: message.from?.emailAddress?.name || message.from?.emailAddress?.address || 'Unknown',
                                receivedDateTime: message.receivedDateTime,
                                bodyPreview: message.bodyPreview || message.body?.content?.substring(0, 200) || '',
                                bodyContent: message.body?.content || ''
                            });
                            newEmailCount++;
                        }
                    });

                    // ä¿æŒæœ€æ–°çš„é‚®ä»¶åœ¨å‰é¢ï¼ˆæœ€å¤šä¿å­˜50å°ï¼‰
                    account.emails.sort((a, b) => new Date(b.receivedDateTime) - new Date(a.receivedDateTime));
                    if (account.emails.length > 50) {
                        account.emails = account.emails.slice(0, 50);
                    }

                    // æå–éªŒè¯ç ï¼ˆè°ƒç”¨æœåŠ¡ç«¯APIï¼‰
                    const verificationCodes = await this.extractVerificationCodes(messages, accountId);

                    // æ·»åŠ éªŒè¯ç åˆ°è´¦æˆ·
                    verificationCodes.forEach(codeData => {
                        this.addCode(accountId, codeData.code, codeData.sender, codeData.received_at);
                    });

                    account.last_sync = new Date().toISOString();
                    account.email_count = account.emails.length;
                    this.saveAccounts();
                    this.render();
                    this.updateStats();

                    console.log(`åŒæ­¥å®Œæˆ: ${account.email}, æ–°é‚®ä»¶: ${newEmailCount}, æ€»é‚®ä»¶: ${account.emails.length}, éªŒè¯ç : ${verificationCodes.length} ä¸ª`);

                } catch (error) {
                    console.error('åŒæ­¥é‚®ä»¶å¤±è´¥:', error);
                    // é™é»˜å¤„ç†é”™è¯¯ï¼Œä¸æ˜¾ç¤ºalertå¼¹çª—
                    throw error;
                }
            }

            // é«˜çº§éªŒè¯ç æå–å™¨ï¼ˆè°ƒç”¨æœåŠ¡ç«¯APIï¼‰
            async extractVerificationCodes(messages, accountId) {
                try {
                    console.log(`[Extract] è°ƒç”¨æœåŠ¡ç«¯APIå¤„ç† ${messages.length} å°é‚®ä»¶`);

                    const response = await fetch('/api/extract-verification-codes', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            sessionId: this.sessionId,
                            messages: messages,
                            accountId: accountId
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        console.log(`[Extract] æœåŠ¡ç«¯æå–å®Œæˆï¼Œæ‰¾åˆ° ${data.results?.length || 0} ä¸ªéªŒè¯ç `);
                        return data.results || [];
                    } else {
                        const errorText = await response.text();
                        console.error('[Extract] æœåŠ¡ç«¯APIè°ƒç”¨å¤±è´¥:', response.status, errorText);
                        return [];
                    }
                } catch (error) {
                    console.error('[Extract] æœåŠ¡ç«¯APIè°ƒç”¨å¼‚å¸¸:', error);
                    return [];
                }
            }

            // æœ¬åœ°éªŒè¯ç æå–å·²ç§»é™¤ - å®Œå…¨ä¾èµ–åç«¯API
            // extractVerificationCodesLocal() - å·²åˆ é™¤ï¼Œä½¿ç”¨æœåŠ¡ç«¯APIæ›¿ä»£

            // æœ¬åœ°é‚®ä»¶è§£æå·²ç§»é™¤ - å®Œå…¨ä¾èµ–åç«¯API
            // parseMessage() - å·²åˆ é™¤ï¼Œä½¿ç”¨æœåŠ¡ç«¯APIæ›¿ä»£

            // æœ¬åœ°æ™ºèƒ½å‘é€è€…è¯†åˆ«å·²ç§»é™¤ - å®Œå…¨ä¾èµ–åç«¯API
            // intelligentSenderRecognition() - å·²åˆ é™¤ï¼Œä½¿ç”¨æœåŠ¡ç«¯APIæ›¿ä»£

            // æœ¬åœ°åŸŸåæå–å·²ç§»é™¤ - å®Œå…¨ä¾èµ–åç«¯API
            // extractDomain() - å·²åˆ é™¤ï¼Œä½¿ç”¨æœåŠ¡ç«¯APIæ›¿ä»£

            // æœ¬åœ°å‘ä»¶äººåç§°æ¸…ç†å·²ç§»é™¤ - å®Œå…¨ä¾èµ–åç«¯API
            // cleanSenderName() - å·²åˆ é™¤ï¼Œä½¿ç”¨æœåŠ¡ç«¯APIæ›¿ä»£

            // è¯†åˆ«å‘ä»¶äººç±»å‹
            identifySenderType(domain, senderName, subject) {
                const domainLower = domain.toLowerCase();
                const senderLower = (senderName || '').toLowerCase();
                const subjectLower = (subject || '').toLowerCase();

                // çŸ¥åæœåŠ¡æä¾›å•†
                if (domainLower.includes('microsoft') || domainLower.includes('outlook') || domainLower.includes('office365')) {
                    return 'microsoft';
                }

                if (domainLower.includes('google') || domainLower.includes('gmail')) {
                    return 'google';
                }

                if (domainLower.includes('apple') || domainLower.includes('icloud')) {
                    return 'apple';
                }

                // ç¤¾äº¤åª’ä½“å¹³å°
                if (domainLower.includes('facebook') || domainLower.includes('instagram') ||
                    domainLower.includes('twitter') || domainLower.includes('linkedin') ||
                    domainLower.includes('tiktok') || domainLower.includes('snapchat')) {
                    return 'social';
                }

                // ç”µå•†å¹³å°
                if (domainLower.includes('amazon') || domainLower.includes('ebay') ||
                    domainLower.includes('taobao') || domainLower.includes('tmall') ||
                    domainLower.includes('jd.com') || domainLower.includes('shopify')) {
                    return 'ecommerce';
                }

                // é‡‘èé“¶è¡Œ
                if (domainLower.includes('bank') || domainLower.includes('paypal') ||
                    domainLower.includes('alipay') || domainLower.includes('wechat') ||
                    domainLower.includes('visa') || domainLower.includes('mastercard')) {
                    return 'financial';
                }

                // æ¸¸æˆå¹³å°
                if (domainLower.includes('game') || domainLower.includes('playstation') ||
                    domainLower.includes('xbox') || domainLower.includes('steam') ||
                    domainLower.includes('epic') || domainLower.includes('nintendo')) {
                    return 'gaming';
                }

                // éªŒè¯æœåŠ¡
                if (senderLower.includes('verification') || senderLower.includes('security') ||
                    senderLower.includes('authenticate') || senderLower.includes('verify') ||
                    domainLower.includes('verify') || domainLower.includes('auth')) {
                    return 'verification';
                }

                // é€šçŸ¥æœåŠ¡
                if (senderLower.includes('notification') || senderLower.includes('noreply') ||
                    senderLower.includes('no-reply') || senderLower.includes('alert') ||
                    domainLower.includes('notification') || domainLower.includes('noreply')) {
                    return 'notification';
                }

                return 'general';
            }

            // å‘ä»¶äººåˆ†ç±»
            categorizeSender(domain, type, subject) {
                const subjectLower = (subject || '').toLowerCase();

                // åŸºäºç±»å‹çš„åˆ†ç±»
                switch (type) {
                    case 'verification':
                        return 'å®‰å…¨éªŒè¯';

                    case 'microsoft':
                    case 'google':
                    case 'apple':
                        return 'ç§‘æŠ€æœåŠ¡';

                    case 'social':
                        return 'ç¤¾äº¤åª’ä½“';

                    case 'ecommerce':
                        return 'ç”µå•†å¹³å°';

                    case 'financial':
                        return 'é‡‘èæœåŠ¡';

                    case 'gaming':
                        return 'æ¸¸æˆå¹³å°';

                    case 'notification':
                        return 'ç³»ç»Ÿé€šçŸ¥';

                    default:
                        // åŸºäºä¸»é¢˜å†…å®¹çš„åˆ†ç±»
                        if (subjectLower.includes('verification') || subjectLower.includes('éªŒè¯') ||
                            subjectLower.includes('code') || subjectLower.includes('éªŒè¯ç ')) {
                            return 'éªŒè¯é€šçŸ¥';
                        }

                        if (subjectLower.includes('welcome') || subjectLower.includes('æ¬¢è¿') ||
                            subjectLower.includes('register') || subjectLower.includes('æ³¨å†Œ')) {
                            return 'æ³¨å†Œé€šçŸ¥';
                        }

                        if (subjectLower.includes('order') || subjectLower.includes('è®¢å•') ||
                            subjectLower.includes('delivery') || subjectLower.includes('é…é€')) {
                            return 'è®¢å•é€šçŸ¥';
                        }

                        if (subjectLower.includes('security') || subjectLower.includes('å®‰å…¨') ||
                            subjectLower.includes('alert') || subjectLower.includes('è­¦å‘Š')) {
                            return 'å®‰å…¨æé†’';
                        }

                        return 'ä¸€èˆ¬é€šçŸ¥';
                }
            }

            // æŸ¥æ‰¾éªŒè¯ç å€™é€‰
            findVerificationCandidates(messageData) {
                const candidates = [];
                const { subject, fullContent } = messageData;

                // é«˜çº§éªŒè¯ç æ¨¡å¼ï¼ˆç§»æ¤è‡ªåŸç³»ç»Ÿï¼‰
                const verificationPatterns = {
                    high: [
                        // éªŒè¯ç å…³é”®è¯ç´§é‚»æ¨¡å¼
                        /(?:verification code|éªŒè¯ç |vertification code)[\s:ï¼š\n\-]*(\d{4,8})/gi,
                        /(?:code|ç )[\s:ï¼š\n\-]*(\d{4,8})/gi,
                        /(?:pin|å¯†ç )[\s:ï¼š\n\-]*(\d{4,8})/gi,
                        /(?:your code is|æ‚¨çš„éªŒè¯ç æ˜¯)[\s:ï¼š\n]*(\d{4,8})/gi,
                        /(?:enter|input|è¯·è¾“å…¥)[\s:ï¼š\n]*(\d{4,8})/gi,
                        // é‚®ä»¶æ ‡é¢˜ä¸­çš„éªŒè¯ç æ¨¡å¼
                        /^\[(\d{4,8})\]/gmi,
                        /^verification[:\s]*(\d{4,8})/gmi
                    ],
                    medium: [
                        // åŒ…å«éªŒè¯ç›¸å…³è¯æ±‡
                        /(?:verify|confirm|confirm|activate|æ¿€æ´»|ç¡®è®¤)[\s\S]{0,50}?(\d{4,8})/gi,
                        /(?:secure|å®‰å…¨|access|ç™»å½•)[\s\S]{0,30}?(\d{4,8})/gi,
                        /(?:otp|one time|ä¸€æ¬¡æ€§)[\s\S]{0,30}?(\d{4,8})/gi,
                        /(?:temporary|ä¸´æ—¶)[\s\S]{0,30}?(\d{4,8})/gi
                    ],
                    low: [
                        /\b(\d{4,8})\b/g
                    ]
                };

                // æŒ‰ä¼˜å…ˆçº§æ£€æŸ¥æ¨¡å¼
                for (const [priority, patterns] of Object.entries(verificationPatterns)) {
                    for (const pattern of patterns) {
                        let match;
                        const regex = new RegExp(pattern);

                        while ((match = regex.exec(fullContent)) !== null) {
                            const code = match[1] || match[0];

                            if (code && /^\d{4,8}$/.test(code)) {
                                const position = match.index;
                                const context = this.analyzeContext(fullContent, code, position);

                                candidates.push({
                                    code,
                                    priority,
                                    position,
                                    context,
                                    pattern: pattern.toString(),
                                    surroundingText: fullContent.substring(
                                        Math.max(0, position - 50),
                                        Math.min(fullContent.length, position + code.length + 50)
                                    )
                                });
                            }
                        }
                    }
                }

                return candidates;
            }

            // åˆ†æä¸Šä¸‹æ–‡
            analyzeContext(content, code, position) {
                const beforeText = content.substring(Math.max(0, position - 100), position);
                const afterText = content.substring(position + code.length, Math.min(content.length, position + code.length + 100));

                return {
                    before: beforeText.trim(),
                    after: afterText.trim(),
                    full: beforeText + code + afterText
                };
            }

            // éªŒè¯éªŒè¯ç æœ‰æ•ˆæ€§ï¼ˆå¢å¼ºç‰ˆï¼‰
            isValidVerificationCode(code, content, context = null) {
                // åŸºæœ¬é•¿åº¦æ£€æŸ¥
                if (!code || code.length < 4 || code.length > 8) {
                    return { valid: false, reason: 'Invalid length' };
                }

                // æ— æ•ˆéªŒè¯ç æ¨¡å¼ï¼ˆç§»æ¤è‡ªåŸç³»ç»Ÿï¼‰
                const invalidPatterns = [
                    /^(\d)\1{3,8}$/, // é‡å¤æ•°å­—
                    /^(?:1234|12345|123456|1234567|12345678)$/, // è¿ç»­æ•°å­—
                    /^20(1[5-9]|2[0-9]|3[0-5])$/, // å¹´ä»½
                    /^\d{5}$/, // ç¾å›½é‚®ç¼–
                    /^(800|888|900|555)\d{4}$/, // å¸¸è§æœåŠ¡å·ç 
                    /^\d{3}[-.\s]?\d{3}[-.\s]?\d{4}$/, // ç”µè¯å·ç 
                    /^(?:ref|Ref|REF)\d+$/, // å¸¸è§IDå‰ç¼€
                    /^(?:order|Order|ORDER)\d+$/,
                    /^(?:invoice|Invoice|INVOICE)\d+$/
                ];

                for (const pattern of invalidPatterns) {
                    if (pattern.test(code)) {
                        return { valid: false, reason: 'Matches invalid pattern' };
                    }
                }

                // ä¸Šä¸‹æ–‡éªŒè¯
                if (context) {
                    const fullContext = `${context.before} ${code} ${context.after}`.toLowerCase();

                    // é«˜å¯ä¿¡åº¦å…³é”®è¯
                    const highTrustKeywords = ['verification code', 'éªŒè¯ç ', 'your code is', 'æ‚¨çš„éªŒè¯ç æ˜¯', 'enter this code'];
                    const mediumTrustKeywords = ['verify', 'confirm', 'activate', 'security', 'access', 'login', 'otp'];

                    let hasHighTrust = highTrustKeywords.some(keyword => fullContext.includes(keyword.toLowerCase()));
                    let hasMediumTrust = mediumTrustKeywords.some(keyword => fullContext.includes(keyword.toLowerCase()));

                    if (!hasHighTrust && !hasMediumTrust && !content.toLowerCase().includes(code.toLowerCase())) {
                        return { valid: false, reason: 'No verification context found' };
                    }
                }

                return { valid: true, reason: 'Valid verification code' };
            }

            // è®¡ç®—éªŒè¯ç åˆ†æ•°
            calculateScore(candidate, messageData) {
                let score = 1.0;

                // ä¼˜å…ˆçº§æƒé‡
                const priorityWeights = { high: 3.0, medium: 2.0, low: 1.0 };
                score += priorityWeights[candidate.priority] || 1.0;

                // ä½ç½®æƒé‡ï¼ˆæ ‡é¢˜ä¸­åˆ†æ•°æ›´é«˜ï¼‰
                if (messageData.subject.includes(candidate.code)) {
                    score += 2.0;
                }

                // ä¸Šä¸‹æ–‡æƒé‡
                if (candidate.context) {
                    const fullContext = candidate.context.before + candidate.code + candidate.context.after;

                    // å…³é”®è¯æƒé‡
                    const keywords = {
                        'verification code': 3.0,
                        'éªŒè¯ç ': 3.0,
                        'your code is': 2.5,
                        'æ‚¨çš„éªŒè¯ç æ˜¯': 2.5,
                        'verify': 2.0,
                        'confirm': 2.0,
                        'security': 1.5,
                        'access': 1.5,
                        'login': 1.5
                    };

                    for (const [keyword, weight] of Object.entries(keywords)) {
                        if (fullContext.toLowerCase().includes(keyword.toLowerCase())) {
                            score += weight;
                        }
                    }
                }

                return Math.round(score * 10) / 10; // ä¿ç•™ä¸€ä½å°æ•°
            }

            // æœç´¢å’Œè¿‡æ»¤
            searchAccounts(query) {
                if (!query) {
                    this.filteredAccounts = [...this.accounts];
                } else {
                    const lowerQuery = query.toLowerCase();
                    this.filteredAccounts = this.accounts.filter(acc =>
                        acc.email.toLowerCase().includes(lowerQuery) ||
                        acc.name.toLowerCase().includes(lowerQuery)
                    );
                }
                this.render();
            }

            filterByStatus(status) {
                if (!status) {
                    this.filteredAccounts = [...this.accounts];
                } else {
                    this.filteredAccounts = this.accounts.filter(acc => acc.status === status);
                }
                this.render();
            }

            // æ’åº
            sortTable(field) {
                if (this.sortField === field) {
                    this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    this.sortField = field;
                    this.sortDirection = 'asc';
                }

                this.applyFilters();
            }

            sortAccounts(accounts) {
                return accounts.sort((a, b) => {
                    let aValue, bValue;

                    switch (this.sortField) {
                        case 'sequence':
                            aValue = a.sequence || a.import_seq || Infinity;
                            bValue = b.sequence || b.import_seq || Infinity;
                            break;
                        case 'status':
                            // å®šä¹‰çŠ¶æ€ä¼˜å…ˆçº§ï¼špending < authorized < reauth_needed < failed < error
                            const statusOrder = { 'pending': 1, 'authorized': 2, 'reauth_needed': 3, 'failed': 4, 'error': 5 };
                            aValue = statusOrder[a.status] || 99;
                            bValue = statusOrder[b.status] || 99;
                            break;
                        case 'email':
                            aValue = a.email.toLowerCase();
                            bValue = b.email.toLowerCase();
                            break;
                        case 'code':
                            // ğŸ”§ ä¿®å¤ï¼šå®‰å…¨æ’åºè·å–æœ€æ–°éªŒè¯ç 
                            aValue = this.getLatestCodeForSort(a)?.code || '';
                            bValue = this.getLatestCodeForSort(b)?.code || '';
                            break;
                        case 'received_time':
                            // ğŸ”§ ä¿®å¤ï¼šå®‰å…¨æ’åºè·å–æœ€æ–°éªŒè¯ç 
                            const aCode = this.getLatestCodeForSort(a);
                            const bCode = this.getLatestCodeForSort(b);
                            aValue = aCode?.received_at ? new Date(aCode.received_at).getTime() : 0;
                            bValue = bCode?.received_at ? new Date(bCode.received_at).getTime() : 0;
                            break;
                        case 'sender':
                            // ğŸ”§ ä¿®å¤ï¼šå®‰å…¨æ’åºè·å–æœ€æ–°éªŒè¯ç 
                            aValue = this.getLatestCodeForSort(a)?.sender || '';
                            bValue = this.getLatestCodeForSort(b)?.sender || '';
                            break;
                        default:
                            return 0;
                    }

                    if (!aValue && !bValue) return 0;
                    if (!aValue) return 1;
                    if (!bValue) return -1;

                    let comparison = 0;
                    if (aValue > bValue) comparison = 1;
                    if (aValue < bValue) comparison = -1;

                    return this.sortDirection === 'desc' ? -comparison : comparison;
                });
            }

            // UIæ“ä½œ
            render() {
                const tbody = document.getElementById('accountsTableBody');
                const totalRecords = this.filteredAccounts.length;

                console.log(`[Render Debug] æ€»è®°å½•æ•°: ${totalRecords}, filteredAccountsé•¿åº¦: ${this.filteredAccounts.length}`);

                if (totalRecords === 0) {
                    console.log('[Render Debug] æ˜¾ç¤ºç©ºçŠ¶æ€æç¤º');
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="8" class="text-center py-8 text-gray-500">
                                <div class="text-6xl mb-4">ğŸ“­</div>
                                <h3 class="text-lg font-medium text-gray-900 mb-2">æš‚æ— é‚®ç®±è´¦æˆ·</h3>
                                <p>ç‚¹å‡»ä¸Šæ–¹"å¯¼å…¥é‚®ç®±"æŒ‰é’®å¼€å§‹ä½¿ç”¨</p>
                            </td>
                        </tr>
                    `;
                    this.updatePaginationInfo(0, 0, 0);
                    return;
                }

                // è®¡ç®—åˆ†é¡µ
                const totalPages = Math.ceil(totalRecords / this.pageSize);
                const from = (this.currentPage - 1) * this.pageSize + 1;
                const to = Math.min(this.currentPage * this.pageSize, totalRecords);

                console.log(`[åˆ†é¡µè°ƒè¯•] æ€»è®°å½•: ${totalRecords}, æ¯é¡µ: ${this.pageSize}, æ€»é¡µæ•°: ${totalPages}, å½“å‰é¡µ: ${this.currentPage}`);
                console.log(`[åˆ†é¡µè°ƒè¯•] æ˜¾ç¤ºèŒƒå›´: ${from} - ${to}`);

                const paginatedAccounts = this.sortAccounts([...this.filteredAccounts])
                    .slice(from - 1, to);

                console.log(`[åˆ†é¡µè°ƒè¯•] æœ¬é¡µæ˜¾ç¤ºè´¦æˆ·æ•°: ${paginatedAccounts.length}`);

                tbody.innerHTML = paginatedAccounts.map((account) => {
                    // ğŸ”§ ä¿®å¤ï¼šå®‰å…¨æ’åºè·å–æœ€æ–°éªŒè¯ç 
                    let latestCode = null;
                    if (account.codes && account.codes.length > 0) {
                        const sortedCodes = [...account.codes].sort((a, b) => {
                            const timeA = new Date(a.received_at).getTime();
                            const timeB = new Date(b.received_at).getTime();
                            return timeB - timeA; // é™åºï¼Œæœ€æ–°çš„åœ¨å‰
                        });
                        latestCode = sortedCodes[0];
                    }
                    const statusIcon = this.getStatusIcon(account.status);
                    const statusClass = this.getStatusClass(account.status);
                    const statusText = this.getStatusText(account.status);

                    return `
                        <tr class="hover:bg-gray-50 transition-colors">
                            <td class="px-3 py-3 whitespace-nowrap text-center w-16">
                                <span class="text-base font-medium text-gray-900 bg-gray-100 px-2 py-1 rounded">
                                    ${account.sequence || account.import_seq || '-'}
                                </span>
                            </td>
                            <td class="px-3 py-3 whitespace-nowrap w-20">
                                <span class="${statusClass}">
                                    <i class="${statusIcon} mr-1"></i>
                                    <span class="text-base">${statusText}</span>
                                </span>
                            </td>
                            <td class="px-4 py-3 whitespace-nowrap w-40">
                                <div class="flex items-center">
                                    <i class="fas fa-envelope text-gray-400 mr-3 text-base"></i>
                                    <span class="text-base font-medium text-gray-900 cursor-pointer hover:text-blue-600 transition truncate"
                                          onclick="copyEmailToClipboard('${account.id}')"
                                          title="${account.email}">
                                        ${account.email}
                                    </span>
                                </div>
                            </td>
                            <td class="px-3 py-3 whitespace-nowrap text-center w-14">
                                <input type="checkbox"
                                       class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 focus:ring-2"
                                       data-account-id="${account.id}"
                                       ${this.selectedAccounts.has(account.id) ? 'checked' : ''}
                                       onchange="handleAccountSelection(this)">
                            </td>
                            <td class="px-3 py-3 whitespace-nowrap w-32 code-cell">
                                <div class="flex flex-col ${account.is_new_code ? 'bg-blue-50 border border-blue-300 rounded' : ''}">
                                    ${this.getVerificationCodeDisplay(account)}
                                </div>
                            </td>
                            <td class="px-3 py-3 whitespace-nowrap text-base text-gray-600 w-28">
                                ${this.getActiveTimeDisplay(account)}
                            </td>
                            <td class="px-3 py-3 whitespace-nowrap text-base text-gray-600 w-24">
                                ${this.getEmailSenderDisplay(account)}
                            </td>
                            <td class="px-3 py-3 whitespace-nowrap w-40">
                                <div class="flex gap-1 flex-wrap">
                                    <!-- æ‰‹åŠ¨å–ä»¶æŒ‰é’® - å§‹ç»ˆæ˜¾ç¤º -->
                                    <button onclick="manualFetchEmails('${account.id}')"
                                            class="px-2 py-1 bg-green-100 text-green-700 hover:bg-green-200 rounded transition text-base"
                                            title="æ‰‹åŠ¨æ”¶å–æœ€æ–°é‚®ä»¶">
                                        å–ä»¶
                                    </button>

                                    <!-- çŠ¶æ€æŒ‰é’®ï¼šé‡æ–°æˆæƒçŠ¶æ€æˆ–å¤åˆ¶æŒ‰é’® -->
                                    ${account.status === 'reauthorizing' ?
                                        `<span class="px-2 py-1 bg-yellow-100 text-yellow-700 rounded text-sm font-medium">
                                            è‡ªåŠ¨é‡æ–°æˆæƒä¸­...
                                        </span>` :
                                        account.reauth_required || account.status === 'reauth_required' || account.status === 'expired_refresh_token' || account.status === 'invalid_refresh_token' ?
                                        `<span class="px-2 py-1 bg-orange-100 text-orange-700 rounded text-sm font-medium">
                                            ç­‰å¾…é‡æ–°æˆæƒ
                                        </span>` :
                                        `<button onclick="copyEmailToClipboard('${account.id}')"
                                                class="px-2 py-1 bg-blue-100 text-blue-700 hover:bg-blue-200 rounded transition text-base">
                                            å¤åˆ¶
                                        </button>`
                                    }

                                    <button onclick="copyLatestCode('${account.id}')"
                                            class="px-2 py-1 bg-purple-100 text-purple-700 hover:bg-purple-200 rounded transition text-base">
                                        éªŒè¯ç 
                                    </button>
                                    <button onclick="deleteAccountConfirm('${account.id}')"
                                            class="px-2 py-1 bg-gray-100 text-gray-700 hover:bg-gray-200 rounded transition text-base">
                                        åˆ é™¤
                                    </button>
                                </div>
                            </td>
                        </tr>
                    `;
                }).join('');

                // æ›´æ–°åˆ†é¡µä¿¡æ¯
                this.updatePaginationInfo(from, to, totalRecords);
                this.renderPagination(totalPages);
            }

            updateStats() {
                const total = this.accounts.length;
                const authorized = this.accounts.filter(acc => acc.status === 'authorized').length;
                const pending = this.accounts.filter(acc => acc.status === 'pending').length;
                const monitoring = this.accounts.filter(acc => acc.is_monitoring).length;

                document.getElementById('totalAccounts').textContent = total;
                document.getElementById('authorizedCount').textContent = authorized;
                document.getElementById('pendingCount').textContent = pending;
                document.getElementById('monitoringCount').textContent = monitoring;
            }

            // å·¥å…·æ–¹æ³•
            getStatusClass(status) {
                const classes = {
                    'authorized': 'text-green-600',
                    'pending': 'text-yellow-600',
                    'reauth_needed': 'text-red-600'
                };
                return classes[status] || 'text-gray-600';
            }

            getStatusIcon(status) {
                const icons = {
                    'authorized': 'fas fa-check-circle',
                    'pending': 'fas fa-clock',
                    'reauth_needed': 'fas fa-exclamation-triangle'
                };
                return icons[status] || 'fas fa-question-circle';
            }

            getStatusText(status) {
                const texts = {
                    'authorized': 'å·²æˆæƒ',
                    'pending': 'å¾…æˆæƒ',
                    'reauth_needed': 'éœ€é‡æ–°æˆæƒ'
                };
                return texts[status] || 'æœªçŸ¥';
            }

            formatTime(timeString) {
                if (!timeString) return '---';

                const date = new Date(timeString);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) return 'åˆšåˆš';
                if (diffMins < 60) return `${diffMins}ï¿½ï¿½é’Ÿå‰`;
                if (diffHours < 24) return `${diffHours}å°æ—¶å‰`;
                if (diffDays < 7) return `${diffDays}å¤©å‰`;

                return date.toLocaleDateString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            formatFullTime(timestamp) {
                if (!timestamp) return '-';
                const date = new Date(timestamp);
                return date.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            }

            // è·å–éªŒè¯ç æ”¶ä»¶æ—¶é—´æ˜¾ç¤º - åªæœ‰å­˜åœ¨éªŒè¯ç æ—¶æ‰æ˜¾ç¤ºæ—¶é—´ï¼ˆå‚è€ƒaccounts_simple.ejsï¼‰
            getActiveTimeDisplay(account) {
                // å¦‚æœæ²¡æœ‰éªŒè¯ç ï¼Œæ˜¾ç¤º"æ— "
                if (!account.codes || account.codes.length === 0) {
                    return '<span class="text-gray-400 text-base">æ— </span>';
                }

                const latestCode = account.codes[0];

                // æ£€æŸ¥æ˜¯å¦æ˜¯çº¯æ•°å­—éªŒè¯ç ï¼ˆåªæœ‰çº¯æ•°å­—éªŒè¯ç æ‰æ˜¾ç¤ºæ—¶é—´ï¼‰
                const isNumericCode = /^\d+$/.test(latestCode.code);
                if (!isNumericCode) {
                    return '<span class="text-gray-400 text-base">æ— </span>';
                }

                // KISS åŸåˆ™ï¼šç§»é™¤å¤æ‚çš„æ—¶é—´æ£€æŸ¥é€»è¾‘
                // åç«¯æå–åˆ°éªŒè¯ç ååº”è¯¥ç«‹å³æ˜¾ç¤ºï¼Œä¸éœ€è¦ç­‰å¾…å†·å´æœŸ
                // æ³¨é‡Šï¼šåˆšå¯¼å…¥çš„è´¦æˆ·ä¹Ÿå¯ä»¥æ˜¾ç¤ºéªŒè¯ç æ—¶é—´

                // æ˜¾ç¤ºéªŒè¯ç æ”¶ä»¶æ—¶é—´
                return this.formatFullTime(latestCode.received_at);
            }

            // å‘ä»¶äººæ˜¾ç¤ºé€»è¾‘ - ç²¾ç®€æ˜¾ç¤ºï¼ˆå‚è€ƒaccounts_simple.ejsï¼‰
            getEmailSenderDisplay(account) {
                if (!account.codes || account.codes.length === 0) {
                    return '<span class="text-gray-400 text-base">æ— </span>';
                }

                const latestCode = account.codes[0];
                if (!latestCode || !latestCode.sender) {
                    return '<span class="text-gray-400 text-base">æ— </span>';
                }

                // KISS åŸåˆ™ï¼šç§»é™¤å¤æ‚çš„æ—¶é—´æ£€æŸ¥é€»è¾‘
                // åç«¯æå–åˆ°éªŒè¯ç ååº”è¯¥ç«‹å³æ˜¾ç¤ºå‘ä»¶äººï¼Œä¸éœ€è¦ç­‰å¾…å†·å´æœŸ
                // æ³¨é‡Šï¼šåˆšå¯¼å…¥çš„è´¦æˆ·ä¹Ÿå¯ä»¥æ˜¾ç¤ºå‘ä»¶äººä¿¡æ¯

                const sender = latestCode.sender;
                let displayName = sender;

                // æç‚¼å‘ä»¶äººåŸŸåæˆ–å…³é”®ä¿¡æ¯
                if (sender.includes('@')) {
                    // é‚®ç®±åœ°å€ï¼Œæå–åŸŸå
                    const domain = sender.split('@')[1];
                    displayName = domain.split('.')[0]; // å–åŸŸåç¬¬ä¸€éƒ¨åˆ†
                } else if (sender.includes('.')) {
                    // å¯èƒ½æ˜¯åŒ…å«åŸŸåçš„æ ¼å¼
                    const parts = sender.split('.');
                    displayName = parts[parts.length - 2] || parts[0];
                }

                // å¦‚æœåå­—å¤ªé•¿ï¼Œæˆªå–
                if (displayName.length > 12) {
                    displayName = displayName.substring(0, 10) + '..';
                }

                // å¸¸è§å‘ä»¶äººçš„å‹å¥½åç§°æ˜ å°„
                const senderMap = {
                    'github': 'GitHub',
                    'microsoft': 'Microsoft',
                    'outlook': 'Outlook',
                    'amazon': 'Amazon',
                    'google': 'Google',
                    'apple': 'Apple',
                    'facebook': 'Facebook',
                    'twitter': 'Twitter',
                    'linkedin': 'LinkedIn',
                    'perplexity': 'Perplexity',
                    'noreply': 'System',
                    'no-reply': 'System'
                };

                const lowerName = displayName.toLowerCase();
                for (const [key, value] of Object.entries(senderMap)) {
                    if (lowerName.includes(key)) {
                        displayName = value;
                        break;
                    }
                }

                return `<span class="text-gray-700 text-base font-medium" title="${sender}">${displayName}</span>`;
            }

            // ğŸ”§ æ–°å¢ï¼šå®‰å…¨æ’åºè¾…åŠ©å‡½æ•°ï¼Œè·å–çœŸæ­£æœ€æ–°çš„éªŒè¯ç 
            getLatestCodeForSort(account) {
                if (!account.codes || account.codes.length === 0) {
                    return null;
                }

                const sortedCodes = [...account.codes].sort((a, b) => {
                    const timeA = new Date(a.received_at).getTime();
                    const timeB = new Date(b.received_at).getTime();
                    return timeB - timeA; // é™åºï¼Œæœ€æ–°çš„åœ¨å‰
                });

                return sortedCodes[0];
            }

            // éªŒè¯ç æ˜¾ç¤ºé€»è¾‘ - åªæ˜¾ç¤ºçº¯æ•°å­—éªŒè¯ç ï¼ˆå‚è€ƒaccounts_simple.ejsï¼‰
            getVerificationCodeDisplay(account) {
                console.log(`[éªŒè¯ç æ˜¾ç¤º] è´¦æˆ· ${account.email} æ•°æ®æ£€æŸ¥:`, {
                    codes: account.codes,
                    codesLength: account.codes?.length || 0,
                    last_sync: account.last_sync,
                    emailsLength: account.emails?.length || 0,
                    monitoring_codes_only: account.monitoring_codes_only
                });

                // å¦‚æœè´¦æˆ·è®¾ç½®äº†åªæ˜¾ç¤ºç›‘æ§æœŸé—´çš„éªŒè¯ç ï¼Œä½†è¿˜æ²¡æœ‰æ–°éªŒè¯ç ï¼Œæ˜¾ç¤º"ç›‘æ§ä¸­..."
                if (account.monitoring_codes_only && (!account.codes || account.codes.length === 0)) {
                    console.log(`[éªŒè¯ç æ˜¾ç¤º] è´¦æˆ· ${account.email} ç›‘æ§ä¸­ï¼Œç­‰å¾…æ–°éªŒè¯ç `);
                    return '<span class="text-blue-500 text-base animate-pulse">ç›‘æ§ä¸­...</span>';
                }

                if (!account.codes || account.codes.length === 0) {
                    console.log(`[éªŒè¯ç æ˜¾ç¤º] è´¦æˆ· ${account.email} æ— éªŒè¯ç æ•°æ®`);
                    return '<span class="text-gray-400 text-base">æ— </span>';
                }

                // ğŸ”§ ä¿®å¤ï¼šå®‰å…¨æ’åºï¼Œç¡®ä¿æ˜¾ç¤ºçœŸæ­£æœ€æ–°çš„éªŒè¯ç 
                const sortedCodes = [...account.codes].sort((a, b) => {
                    const timeA = new Date(a.received_at).getTime();
                    const timeB = new Date(b.received_at).getTime();
                    return timeB - timeA; // é™åºï¼Œæœ€æ–°çš„åœ¨å‰
                });

                const latestCode = sortedCodes[0];
                console.log(`[éªŒè¯ç æ˜¾ç¤º] è´¦æˆ· ${account.email} æ’åºåæœ€æ–°éªŒè¯ç :`, latestCode);
                console.log(`[éªŒè¯ç æ˜¾ç¤º] è´¦æˆ· ${account.email} éªŒè¯ç æ€»æ•°: ${account.codes.length}`);

                // éªŒè¯ç æ˜¾ç¤ºé€»è¾‘ï¼šåªè¦æ˜¯ä»æœ€è¿‘5å°é‚®ä»¶ä¸­æå–çš„éªŒè¯ç å°±æ˜¾ç¤º
                // è¿™åŒ…æ‹¬å¯¼å…¥æ—¶è‡ªåŠ¨è·å–çš„éªŒè¯ç å’Œæ‰‹åŠ¨åŒæ­¥è·å–çš„éªŒè¯ç 
                // ä¸åŸºäºæ—¶é—´åˆ¤æ–­ï¼ŒåŸºäºæ•°æ®æ¥æºåˆ¤æ–­ï¼ˆä»æœ€æ–°é‚®ä»¶æå–ï¼‰

                // å¦‚æœè´¦æˆ·æœ‰é‚®ä»¶ï¿½ï¿½æ®ï¼Œè¯´æ˜å·²ç»è¿›è¡Œè¿‡é‚®ä»¶åŒæ­¥
                const hasEmailData = account.emails && account.emails.length > 0;

                // å¦‚æœè´¦æˆ·æœ‰last_syncæ—¶é—´æˆ³ï¼Œè¯´æ˜è¿›è¡Œè¿‡é‚®ä»¶åŒæ­¥
                const hasBeenSynced = !!account.last_sync;

                console.log(`[éªŒè¯ç æ˜¾ç¤º] è´¦æˆ· ${account.email} åŒæ­¥çŠ¶æ€:`, {
                    hasEmailData,
                    hasBeenSynced,
                    last_sync: account.last_sync
                });

                // ç®€åŒ–éªŒè¯ç æ˜¾ç¤ºé€»è¾‘ï¼šåªè¦æœ‰éªŒè¯ç æ•°æ®å°±æ˜¾ç¤º
                // åç«¯å·²ç»æˆåŠŸæå–äº†éªŒè¯ç ï¼Œåº”è¯¥ç«‹å³æ˜¾ç¤º
                console.log(`[éªŒè¯ç æ˜¾ç¤º] è´¦æˆ· ${account.email} å°†æ˜¾ç¤ºéªŒè¯ç ï¼Œè·³è¿‡åŒæ­¥æ£€æŸ¥`);

                // æ£€æŸ¥æ˜¯å¦ä¸ºçº¯æ•°å­—éªŒè¯ç 
                const isNumericCode = /^\d+$/.test(latestCode.code);

                if (isNumericCode) {
                    // æ˜¯çº¯æ•°å­—éªŒè¯ç 
                    return `
                        <div class="flex items-center gap-2">
                            <span class="text-code cursor-pointer" onclick="copyLatestCode('${account.id}')" title="ç‚¹å‡»å¤åˆ¶éªŒè¯ç ">
                                ${latestCode.code}
                                <i class="fas fa-copy ml-1 text-xs"></i>
                            </span>
                        </div>
                    `;
                } else {
                    // ä¸æ˜¯çº¯æ•°å­—éªŒè¯ç ï¼Œæ˜¾ç¤ºä¸º"æ— "
                    return '<span class="text-gray-400 text-base">æ— </span>';
                }
            }

            // æ ‡è®°æ–°éªŒè¯ç ï¼ˆKISSæ–¹æ¡ˆï¼š10ç§’è“è‰²èƒŒæ™¯æé†’ï¼‰
            markNewVerificationCode(accountId) {
                const account = this.accounts.find(acc => acc.id === accountId);
                if (!account) return;

                console.log(`[æ–°éªŒè¯ç ] è´¦æˆ· ${account.email} è·å–åˆ°æ–°éªŒè¯ç ï¼Œå¼€å§‹10ç§’æé†’`);

                // è®¾ç½®æ–°éªŒè¯ç æ ‡è®°
                account.is_new_code = true;

                // ç«‹å³ä¿å­˜å¹¶æ¸²æŸ“
                this.saveAccounts();
                this.render();

                // 10ç§’åè‡ªåŠ¨æ¸…é™¤æ ‡è®°
                setTimeout(() => {
                    if (account.is_new_code) {
                        account.is_new_code = false;
                        console.log(`[æ–°éªŒè¯ç ] è´¦æˆ· ${account.email} 10ç§’æé†’ç»“æŸ`);
                        this.saveAccounts();
                        this.render();
                    }
                }, 10000);
            }

            // æ•°æ®å¯¼å‡ºåŠŸèƒ½å·²ä¸‹çº¿ - åŸåŠŸèƒ½ä»£ç å·²æ³¨é‡Š
            // exportData() {
            //     if (this.accounts.length === 0) {
            //         alert('æš‚æ— æ•°æ®å¯å¯¼å‡º');
            //         return;
            //     }
            //
            //     const exportData = {
            //         accounts: this.accounts,
            //         export_time: new Date().toISOString(),
            //         version: '2.0',
            //         statistics: {
            //             total_accounts: this.accounts.length,
            //             authorized_accounts: this.accounts.filter(acc => acc.status === 'authorized').length,
            //             total_codes: this.accounts.reduce((sum, acc) => sum + acc.codes.length, 0)
            //         }
            //     };
            //
            //     const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            //     const url = URL.createObjectURL(blob);
            //     const a = document.createElement('a');
            //     a.href = url;
            //     a.download = `mailmanager_backup_${new Date().toISOString().split('T')[0]}.json`;
            //     document.body.appendChild(a);
            //     a.click();
            //     document.body.removeChild(a);
            //     URL.revokeObjectURL(url);
            //
            //     alert('æ•°æ®å¯¼å‡ºæˆåŠŸ');
            // }

            // æ•°æ®å¯¼å…¥åŠŸèƒ½å·²ä¸‹çº¿ - åŸåŠŸèƒ½ä»£ç å·²æ³¨é‡Š
            // importData(data) {
            //     if (data.accounts && Array.isArray(data.accounts)) {
            //         this.accounts = data.accounts;
            //         this.filteredAccounts = [...this.accounts];
            //         this.saveAccounts();
            //         this.render();
            //         this.updateStats();
            //         return true;
            //     }
            //     return false;
            // }

            // å¤åˆ¶é‚®ç®±åœ°å€å¹¶è‡ªåŠ¨å¯åŠ¨ç›‘æ§
            async copyEmailToClipboard(accountId) {
                const account = this.accounts.find(acc => acc.id === accountId);
                if (!account) {
                    console.error(`[é”™è¯¯] æ‰¾ä¸åˆ°è´¦æˆ·ID: ${accountId}`);
                    return;
                }

                // ç§»é™¤é˜²æŠ–æœºåˆ¶ï¼šå…è®¸ç”¨æˆ·éšæ—¶è§¦å‘ç›‘æ§

                try {
                    await navigator.clipboard.writeText(account.email);
                    this.showSuccess('é‚®ç®±å·²å¤åˆ¶: ' + account.email);

                    // ç§»é™¤è§¦å‘æ—¶é—´è®°å½•ï¼ˆé˜²æŠ–æœºåˆ¶å·²å–æ¶ˆï¼‰

                    // ä»…åœ¨ç‰¹å®šåœºæ™¯è§¦å‘ç›‘æ§ï¼šå¤åˆ¶é‚®ç®±è§¦å‘åå°ç›‘æ§
                    // ç›‘æ§å°†åœ¨åç«¯æŒç»­è¿è¡Œ60ç§’ç›´åˆ°æˆåŠŸè·å–éªŒè¯ç 
                    console.log(`[ç›‘æ§] å¼€å§‹ä¸ºè´¦æˆ· ${account.email} å¯åŠ¨1åˆ†é’Ÿç›‘æ§ï¼ˆå°†æŒç»­è¿è¡Œç›´åˆ°æˆåŠŸï¼‰`);

                    // å¤åˆ¶é‚®ç®±ç›‘æ§æ—¶ï¼Œæ ‡è®°åªæ˜¾ç¤ºæ–°è·å–çš„éªŒè¯ç 
                    console.log(`[ç›‘æ§] è´¦æˆ· ${account.email} å¼€å§‹ç›‘æ§ï¼Œå°†åªæ˜¾ç¤ºæ–°è·å–çš„éªŒè¯ç `);
                    account.monitoring_codes_only = true; // æ ‡è®°åªæ˜¾ç¤ºç›‘æ§æœŸé—´çš„éªŒè¯ç 
                    account.last_sync = null; // é‡ç½®åŒæ­¥æ—¶é—´

                    // ä¿å­˜ä½†ä¸é‡æ–°æ¸²æŸ“UIï¼Œé¿å…é—ªçƒ
                    this.saveAccounts();

                    // ç›´æ¥å¯åŠ¨ç›‘æ§ï¼Œåç«¯ä¼šè‡ªåŠ¨å¤„ç†æˆæƒæ£€æŸ¥å’Œé‚®ä»¶è·å–
                    await this.startMonitoringForAccount(account);
                } catch (error) {
                    console.warn('[ç›‘æ§] å¯åŠ¨ç›‘æ§å¤±è´¥:', error);
                    this.showError('å¯åŠ¨ç›‘æ§å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
                }
            }

            // ä¸ºç‰¹å®šè´¦æˆ·å¯åŠ¨ç›‘æ§
            async startMonitoringForAccount(account) {
                try {
                    const response = await fetch('/api/monitor/copy-trigger', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            sessionId: this.sessionId,
                            account_id: account.id,
                            email: account.email,
                            client_id: account.client_id,
                            refresh_token: account.refresh_token,
                            current_status: account.status,
                            access_token: account.access_token,
                            // æ–°å¢ï¼šä¼ é€’å†å²é‚®ä»¶æ•°æ®ç”¨äºæ—¶é—´è¿‡æ»¤
                            codes: account.codes || [],
                            emails: account.emails || [],
                            latest_code_received_at: account.latest_code_received_at || null,
                            last_active_at: account.last_active_at || null
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        this.showSuccess('å·²å¯åŠ¨1åˆ†é’Ÿç›‘æ§ï¼Œç³»ç»Ÿå°†è‡ªåŠ¨å¤„ç†æˆæƒå¹¶æ£€æŸ¥æ–°é‚®ä»¶', 'success');
                        console.log('[ç›‘æ§] å·²ä¸ºè´¦æˆ·', account.email, 'å¯åŠ¨ç›‘æ§ï¼Œåç«¯å°†è‡ªåŠ¨æ£€æŸ¥æˆæƒå’Œè·å–é‚®ä»¶');

                        // æ›´æ–°è´¦æˆ·ç›‘æ§çŠ¶æ€
                        account.is_monitoring = true;
                        account.last_active_at = new Date().toISOString();
                        this.saveAccounts();
                        this.updateStats();
                        this.render();
                    } else {
                        console.warn('[ç›‘æ§] å¯åŠ¨ç›‘æ§å¤±è´¥:', response.statusText);
                        this.showError('ç›‘æ§å¯åŠ¨å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
                    }
                } catch (monitorError) {
                    console.warn('[ç›‘æ§] å¯åŠ¨ç›‘æ§å¤±è´¥:', monitorError);
                    this.showError('ç›‘æ§å¯åŠ¨å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
                }
            }

            // è‡ªåŠ¨é‡æ–°æˆæƒå°è¯•
            async attemptAutoReauth(account) {
                console.log(`[è‡ªåŠ¨æˆæƒ] å¼€å§‹ä¸ºè´¦æˆ· ${account.email} å°è¯•è‡ªåŠ¨é‡æ–°æˆæƒ`);
                this.updateAccountStatus(account.id, 'reauth_needed');

                try {
                    // æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„æˆæƒä¿¡æ¯
                    if (!account.client_id || !account.refresh_token) {
                        console.warn(`[è‡ªåŠ¨æˆæƒ] è´¦æˆ· ${account.email} ç¼ºå°‘æˆæƒä¿¡æ¯ï¼Œæ— æ³•è‡ªåŠ¨é‡æ–°æˆæƒ`);
                        this.showNotification(`è´¦æˆ· ${account.email} ç¼ºå°‘æˆæƒä¿¡æ¯ï¼Œéœ€è¦æ‰‹åŠ¨æ›´æ–°`, 'error');
                        return false;
                    }

                    // å°è¯•ä½¿ç”¨å½“å‰çš„refresh_tokenè·å–æ–°çš„access_token
                    const tokenResponse = await fetch('/api/microsoft/token', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            client_id: account.client_id,
                            refresh_token: account.refresh_token,
                            grant_type: 'refresh_token'
                        })
                    });

                    if (tokenResponse.ok) {
                        const tokenData = await tokenResponse.json();
                        console.log(`[è‡ªåŠ¨æˆæƒ] è´¦æˆ· ${account.email} è‡ªåŠ¨é‡æ–°æˆæƒæˆåŠŸ`);

                        // æ›´æ–°access_token
                        if (tokenData.access_token) {
                            account.access_token = tokenData.access_token;
                            // å¦‚æœæœ‰æ–°çš„refresh_tokenï¼Œä¹Ÿæ›´æ–°å®ƒ
                            if (tokenData.refresh_token) {
                                account.refresh_token = tokenData.refresh_token;
                            }

                            // æ›´æ–°è´¦æˆ·çŠ¶æ€ä¸ºå·²æˆæƒ
                            this.updateAccountStatus(account.id, 'authorized');
                            this.saveAccounts();

                            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                            this.showNotification(`è´¦æˆ· ${account.email} å·²è‡ªåŠ¨é‡æ–°æˆæƒæˆåŠŸ`, 'success');

                            // ç«‹å³å¯åŠ¨ç›‘æ§
                            await this.startMonitoringForAccount(account);

                            return true;
                        }
                    } else {
                        console.warn(`[è‡ªåŠ¨æˆæƒ] è´¦æˆ· ${account.email} è‡ªåŠ¨é‡æ–°æˆæƒå¤±è´¥: ${tokenResponse.status}`);
                        this.showNotification(`è´¦æˆ· ${account.email} è‡ªåŠ¨é‡æ–°æˆæƒå¤±è´¥ï¼Œå¯èƒ½éœ€è¦æ‰‹åŠ¨æ›´æ–°æˆæƒä¿¡æ¯`, 'warning');
                        return false;
                    }
                } catch (error) {
                    console.error(`[è‡ªåŠ¨æˆæƒ] è´¦æˆ· ${account.email} è‡ªåŠ¨é‡æ–°æˆæƒå¼‚å¸¸:`, error);
                    this.showNotification(`è´¦æˆ· ${account.email} è‡ªåŠ¨é‡æ–°æˆæƒå¤±è´¥: ${error.message}`, 'error');
                    return false;
                }
            }

            // å¤„ç†éœ€è¦é‡æ–°æˆæƒçš„æƒ…å†µï¼ˆä¿ç•™ä¸ºå¤‡ç”¨æ–¹æ³•ï¼‰
            handleReauthRequired(account, message) {
                // æ›´æ–°è´¦æˆ·çŠ¶æ€ä¸ºéœ€è¦é‡æ–°æˆæƒ
                this.updateAccountStatus(account.id, 'reauth_needed');

                // æ˜¾ç¤ºè¯¦ç»†çš„é‡æ–°æˆæƒæŒ‡å¯¼
                this.showNotification(`${message}`, 'warning');

                // åˆ›å»ºé‡æ–°æˆæƒæŒ‡å¯¼å¼¹çª—
                const reauthModal = document.createElement('div');
                reauthModal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                reauthModal.innerHTML = `
                    <div class="bg-white rounded-lg p-6 max-w-md mx-4">
                        <div class="text-center">
                            <i class="fas fa-exclamation-triangle text-yellow-500 text-4xl mb-4"></i>
                            <h3 class="text-lg font-bold mb-2">éœ€è¦é‡æ–°æˆæƒ</h3>
                            <p class="text-gray-600 mb-4">${message}</p>
                            <div class="bg-blue-50 border border-blue-200 rounded p-3 mb-4">
                                <p class="text-sm text-blue-800"><strong>è§£å†³æ­¥éª¤ï¼š</strong></p>
                                <ol class="text-sm text-blue-700 text-left mt-2 list-decimal list-inside">
                                    <li>è·å–æ–°çš„ ${account.client_id ? 'Client ID' : 'æˆæƒä¿¡æ¯'}</li>
                                    <li>è·å–æ–°çš„ Refresh Token</li>
                                    <li>ç‚¹å‡»"ç¼–è¾‘"æŒ‰é’®æ›´æ–°è´¦æˆ·ä¿¡æ¯</li>
                                    <li>é‡æ–°ç‚¹å‡»é‚®ç®±åœ°å€å¯åŠ¨ç›‘æ§</li>
                                </ol>
                            </div>
                            <div class="flex gap-3 justify-center">
                                <button onclick="this.closest('.fixed').remove()" class="px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300">
                                    ç¨åå¤„ç†
                                </button>
                                <button onclick="window.mailmanager.showAccountEditModal('${account.id}'); this.closest('.fixed').remove();" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                                    ç«‹å³æ›´æ–°
                                </button>
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(reauthModal);

                // 8ç§’åè‡ªåŠ¨ç§»é™¤å¼¹çª—ï¼ˆå¦‚æœç”¨æˆ·æ²¡æœ‰æ“ä½œï¼‰
                setTimeout(() => {
                    if (document.body.contains(reauthModal)) {
                        reauthModal.remove();
                    }
                }, 8000);
            }

            // å¤åˆ¶æœ€æ–°éªŒè¯ç 
            async copyLatestCode(accountId) {
                const account = this.accounts.find(acc => acc.id === accountId);
                if (!account || !account.codes || account.codes.length === 0) {
                    this.showError('æš‚æ— éªŒè¯ç å¯å¤åˆ¶');
                    return;
                }

                // ğŸ”§ ä¿®å¤ï¼šå®‰å…¨æ’åºè·å–æœ€æ–°éªŒè¯ç 
                let latestCode = null;
                if (account.codes && account.codes.length > 0) {
                    const sortedCodes = [...account.codes].sort((a, b) => {
                        const timeA = new Date(a.received_at).getTime();
                        const timeB = new Date(b.received_at).getTime();
                        return timeB - timeA; // é™åºï¼Œæœ€æ–°çš„åœ¨å‰
                    });
                    latestCode = sortedCodes[0];
                }

                if (!latestCode) {
                    this.showNotification('æ²¡æœ‰å¯å¤åˆ¶çš„éªŒè¯ç ', 'error');
                    return;
                }

                try {
                    await navigator.clipboard.writeText(latestCode.code);
                    this.showSuccess('éªŒè¯ç å·²å¤åˆ¶: ' + latestCode.code);
                } catch (error) {
                    console.error('å¤åˆ¶éªŒè¯ç å¤±è´¥:', error);
                    this.showError('å¤åˆ¶å¤±è´¥');
                }
            }

            // åˆ†é¡µç›¸å…³æ–¹æ³•
            updatePaginationInfo(from, to, total) {
                document.getElementById('showingFrom').textContent = from || 0;
                document.getElementById('showingTo').textContent = to || 0;
                document.getElementById('totalRecords').textContent = total || 0;
            }

            renderPagination(totalPages) {
                const paginationDiv = document.getElementById('pagination');
                if (totalPages <= 1) {
                    paginationDiv.innerHTML = '';
                    return;
                }

                let paginationHTML = '';

                // ä¸Šä¸€é¡µæŒ‰é’®
                const prevDisabled = this.currentPage === 1 ? 'disabled' : '';
                paginationHTML += `<button class="page-btn" onclick="changePage(-1)" ${prevDisabled}>ä¸Šä¸€é¡µ</button>`;

                // é¡µç æŒ‰é’®
                const startPage = Math.max(1, this.currentPage - 2);
                const endPage = Math.min(totalPages, this.currentPage + 2);

                if (startPage > 1) {
                    paginationHTML += `<button class="page-btn" onclick="goToPage(1)">1</button>`;
                    if (startPage > 2) {
                        paginationHTML += `<span class="px-2">...</span>`;
                    }
                }

                for (let i = startPage; i <= endPage; i++) {
                    const activeClass = i === this.currentPage ? 'active' : '';
                    paginationHTML += `<button class="page-btn ${activeClass}" onclick="goToPage(${i})">${i}</button>`;
                }

                if (endPage < totalPages) {
                    if (endPage < totalPages - 1) {
                        paginationHTML += `<span class="px-2">...</span>`;
                    }
                    paginationHTML += `<button class="page-btn" onclick="goToPage(${totalPages})">${totalPages}</button>`;
                }

                // ä¸‹ä¸€é¡µæŒ‰é’®
                const nextDisabled = this.currentPage === totalPages ? 'disabled' : '';
                paginationHTML += `<button class="page-btn" onclick="changePage(1)" ${nextDisabled}>ä¸‹ä¸€é¡µ</button>`;

                paginationDiv.innerHTML = paginationHTML;
            }

            changePageSize(newPageSize) {
                this.pageSize = parseInt(newPageSize);
                this.currentPage = 1; // é‡ç½®åˆ°ç¬¬ä¸€é¡µ
                this.render();
            }

            changePage(delta) {
                const totalRecords = this.filteredAccounts.length;
                const totalPages = Math.ceil(totalRecords / this.pageSize);
                const newPage = this.currentPage + delta;

                if (newPage >= 1 && newPage <= totalPages) {
                    this.currentPage = newPage;
                    this.render();
                }
            }

            goToPage(page) {
                const totalRecords = this.filteredAccounts.length;
                const totalPages = Math.ceil(totalRecords / this.pageSize);

                if (page >= 1 && page <= totalPages) {
                    this.currentPage = page;
                    this.render();
                }
            }

            // é«˜æ•ˆå¼‚æ­¥å¯¼å…¥éªŒè¯ç³»ç»Ÿ - ä½¿ç”¨æ‰¹é‡APIä¼˜åŒ–
            async startAsyncImportValidation() {
                const pendingAccounts = this.accounts.filter(acc => acc.status === 'pending');
                if (pendingAccounts.length === 0) return;

                console.log(`[æ‰¹é‡å¯¼å…¥] å¼€å§‹æ‰¹é‡å¤„ç† ${pendingAccounts.length} ä¸ªå¾…éªŒè¯è´¦æˆ·`);

                try {
                    // ç¡®ä¿sessionIdå­˜åœ¨
                    if (!this.sessionId) {
                        const savedSessionId = localStorage.getItem('mail_manager_session_id');
                        if (savedSessionId) {
                            this.sessionId = savedSessionId;
                        } else {
                            this.sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                            localStorage.setItem('mail_manager_session_id', this.sessionId);
                        }
                        console.log(`[æ‰¹é‡å¯¼å…¥] ä¼šè¯ID: ${this.sessionId}`);
                    }

                    // å‡†å¤‡æ‰¹é‡å¯¼å…¥æ•°æ®ï¼ˆä½¿ç”¨åç«¯å·²å®ç°çš„batch-importæ¥å£æ ¼å¼ï¼‰
                    const emailsData = pendingAccounts.map(account => ({
                        email: account.email,
                        password: account.email, // å¯†ç å­—æ®µï¼Œåç«¯éœ€è¦ä½†ä¸å®é™…ä½¿ç”¨
                        client_id: account.client_id,
                        refresh_token: account.refresh_token
                    }));

                    console.log(`[æ‰¹é‡å¯¼å…¥] è°ƒç”¨åç«¯batch-importæ¥å£ï¼Œå¤„ç† ${emailsData.length} ä¸ªè´¦æˆ·`);

                    // è°ƒç”¨åç«¯çš„batch-importæ¥å£ï¼ˆå·²å®Œæ•´å®ç°æˆæƒã€å–ä»¶ã€æå–éªŒè¯ç ï¼‰
                    const response = await fetch('/api/accounts/batch-import', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            sessionId: this.sessionId,
                            emails: emailsData
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`æ‰¹é‡å¯¼å…¥å¤±è´¥: ${response.status}`);
                    }

                    const result = await response.json();
                    console.log(`[æ‰¹é‡å¯¼å…¥] åç«¯å¤„ç†å®Œæˆ:`, result);

                    // æ›´æ–°å‰ç«¯è´¦æˆ·çŠ¶æ€
                    let successCount = 0;
                    let failureCount = 0;

                    result.results.forEach(importResult => {
                        const account = this.accounts.find(acc => acc.email === importResult.email);
                        if (account) {
                            if (importResult.success) {
                                // æ›´æ–°è´¦æˆ·IDï¼ˆåç«¯ç”Ÿæˆçš„æ–°IDï¼‰
                                account.id = importResult.account_id;
                                account.status = 'authorized';
                                account.sequence = importResult.sequence;
                                account.last_check = new Date().toISOString();
                                successCount++;
                                console.log(`[æ‰¹é‡å¯¼å…¥] è´¦æˆ· ${account.email} å¯¼å…¥æˆåŠŸï¼Œåºåˆ—å·: ${importResult.sequence}`);
                            } else {
                                account.status = 'failed';
                                account.error = importResult.error;
                                failureCount++;
                                console.log(`[æ‰¹é‡å¯¼å…¥] è´¦æˆ· ${account.email} å¯¼å…¥å¤±è´¥: ${importResult.error}`);
                            }
                        }
                    });

                    // æ›´æ–°UIå’Œå­˜å‚¨
                    this.updateStats();
                    this.saveAccounts();
                    this.render();

                    // æ˜¾ç¤ºé€šçŸ¥
                    if (successCount > 0) {
                        this.showNotification(
                            `æ‰¹é‡å¯¼å…¥å®Œæˆ: ${successCount} æˆåŠŸ${failureCount > 0 ? `, ${failureCount} å¤±è´¥` : ''}ã€‚éªŒè¯ç å°†åœ¨åå°å¼‚æ­¥æå–ã€‚`,
                            successCount === result.results.length ? 'success' : 'warning'
                        );
                    }

                    console.log(`[æ‰¹é‡å¯¼å…¥] å®Œæˆç»Ÿè®¡: ${successCount} æˆåŠŸ, ${failureCount} å¤±è´¥`);
                    console.log(`[æ‰¹é‡å¯¼å…¥] åç«¯æ­£åœ¨å¼‚æ­¥å¤„ç†å–ä»¶å’ŒéªŒè¯ç æå–ï¼Œè¯·ç­‰å¾…SSEäº‹ä»¶é€šçŸ¥`);

                } catch (error) {
                    console.error(`[æ‰¹é‡å¯¼å…¥] å¤„ç†å¤±è´¥:`, error);
                    this.showNotification(`æ‰¹é‡å¯¼å…¥å¤±è´¥: ${error.message}`, 'error');

                    // å°†æ‰€æœ‰pendingè´¦æˆ·æ ‡è®°ä¸ºerror
                    pendingAccounts.forEach(account => {
                        account.status = 'error';
                        account.error = error.message;
                    });
                    this.saveAccounts();
                    this.render();
                }
            }

            // validateAccountAsync æ–¹æ³•å·²åˆ é™¤ - ç°åœ¨ä½¿ç”¨æ‰¹é‡éªŒè¯API /api/accounts/batch-validate

            // quickTokenCheck æ–¹æ³•å·²åˆ é™¤ - ç°åœ¨ä½¿ç”¨ /api/accounts/validate ç»Ÿä¸€API

            // fetchRecentEmailsFast æ–¹æ³•å·²åˆ é™¤ - ç°åœ¨ä½¿ç”¨ /api/accounts/validate ç»Ÿä¸€API

            // å¤„ç†Tokenåˆ·æ–° - ç®€å•ç›´æ¥çš„curlæ–¹å¼
            async handleReauthorization(invalidAccounts) {
                console.log(`[Tokenåˆ·æ–°] å¼€å§‹å¤„ç† ${invalidAccounts.length} ä¸ªå¤±æ•ˆè´¦æˆ·`);

                for (const invalid of invalidAccounts) {
                    const account = this.accounts.find(acc => acc.id === invalid.account_id);
                    if (account) {
                        try {
                            console.log(`[Tokenåˆ·æ–°] ç›´æ¥åˆ·æ–°è´¦æˆ· ${account.email} çš„Token`);

                            // è°ƒç”¨åç«¯ç›´æ¥åˆ·æ–°Tokenï¼ˆå®Œå…¨æ¨¡æ‹Ÿcurlæ–¹å¼ï¼‰
                            const formData = new URLSearchParams();
                            formData.append('client_id', account.client_id);
                            formData.append('refresh_token', account.refresh_token);
                            formData.append('grant_type', 'refresh_token');

                            const response = await fetch('/api/accounts/refresh-token-direct', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                                body: formData
                            });

                            if (response.ok) {
                                const result = await response.json();
                                console.log(`[Tokenåˆ·æ–°] è´¦æˆ· ${account.email} Tokenåˆ·æ–°æˆåŠŸ`);

                                // æ›´æ–°è´¦æˆ·Token
                                account.access_token = result.access_token;
                                account.refresh_token = result.refresh_token;
                                account.status = 'authorized';
                                account.last_updated = new Date().toISOString();

                                // ä¿å­˜è´¦æˆ·æ•°æ®å¹¶æ›´æ–°ç•Œé¢
                                this.saveAccounts();
                                this.render();
                                this.updateStats();

                                // Tokenåˆ·æ–°æˆåŠŸåï¼Œç«‹å³è·å–é‚®ä»¶å’ŒéªŒè¯ç 
                                console.log(`[Tokenåˆ·æ–°] è´¦æˆ· ${account.email} å¼€å§‹è·å–é‚®ä»¶å’ŒéªŒè¯ç `);
                                this.fetchEmailsAfterTokenRefresh(account);

                                this.showNotification(`è´¦æˆ· ${account.email} Tokenå·²è‡ªåŠ¨åˆ·æ–°`, 'success');

                            } else {
                                console.error(`[Tokenåˆ·æ–°] è´¦æˆ· ${account.email} Tokenåˆ·æ–°å¤±è´¥`);
                                this.showNotification(`è´¦æˆ· ${account.email} Tokenåˆ·æ–°å¤±è´¥`, 'error');
                            }

                        } catch (error) {
                            console.error(`[Tokenåˆ·æ–°] å¤„ç†è´¦æˆ· ${account.email} æ—¶å‡ºé”™:`, error);
                            this.showNotification(`è´¦æˆ· ${account.email} Tokenåˆ·æ–°å¤±è´¥`, 'error');
                        }
                    }
                }

                // ä¿å­˜å¹¶åˆ·æ–°UI
                this.saveAccounts();
                this.render();
            }

            // Tokenåˆ·æ–°æˆåŠŸåè·å–é‚®ä»¶å’ŒéªŒè¯ç 
            async fetchEmailsAfterTokenRefresh(account) {
                try {
                    console.log(`[é‚®ä»¶è·å–] å¼€å§‹è·å–è´¦æˆ· ${account.email} çš„é‚®ä»¶å’ŒéªŒè¯ç `);

                    // è°ƒç”¨åç«¯APIè·å–é‚®ä»¶
                    const response = await fetch('/api/manual-fetch-emails', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            account_id: account.id,
                            email: account.email,
                            client_id: account.client_id,
                            refresh_token: account.refresh_token,
                            access_token: account.access_token,
                            current_status: account.status,
                            sessionId: this.sessionId
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log(`[é‚®ä»¶è·å–] è´¦æˆ· ${account.email} é‚®ä»¶è·å–æˆåŠŸ:`, result);

                        if (result.success && result.verification_codes && result.verification_codes.length > 0) {
                            console.log(`[é‚®ä»¶è·å–] è´¦æˆ· ${account.email} æå–åˆ° ${result.verification_codes.length} ä¸ªéªŒè¯ç `);
                            this.showNotification(`è´¦æˆ· ${account.email} å‘ç° ${result.verification_codes.length} ä¸ªéªŒè¯ç `, 'success');
                        } else {
                            console.log(`[é‚®ä»¶è·å–] è´¦æˆ· ${account.email} æœªå‘ç°éªŒè¯ç `);
                            this.showNotification(`è´¦æˆ· ${account.email} æœªå‘ç°éªŒè¯ç `, 'info');
                        }
                    } else {
                        const error = await response.text();
                        console.error(`[é‚®ä»¶è·å–] è´¦æˆ· ${account.email} é‚®ä»¶è·å–å¤±è´¥:`, error);
                        this.showNotification(`è´¦æˆ· ${account.email} é‚®ä»¶è·å–å¤±è´¥`, 'error');
                    }
                } catch (error) {
                    console.error(`[é‚®ä»¶è·å–] å¤„ç†è´¦æˆ· ${account.email} æ—¶å‡ºé”™:`, error);
                    this.showNotification(`è´¦æˆ· ${account.email} é‚®ä»¶è·å–å¼‚å¸¸`, 'error');
                }
            }

            // æ˜¾ç¤ºé‡æ–°æˆæƒé€‰é¡¹
            showReauthorizationOptions(invalidAccounts) {
                const reauthRequired = invalidAccounts.filter(inv =>
                    inv.status === 'expired_refresh_token' || inv.status === 'invalid_refresh_token'
                );

                if (reauthRequired.length > 0) {
                    this.showNotification(
                        `æ£€æµ‹åˆ° ${reauthRequired.length} ä¸ªè´¦æˆ·éœ€è¦é‡æ–°æˆæƒã€‚æ‚¨å¯ä»¥é€‰æ‹©ï¼š\n` +
                        `1. ç‚¹å‡»"é‡æ–°æˆæƒ"æŒ‰é’®é€ä¸ªå¤„ç†\n` +
                        `2. ä½¿ç”¨æ‰¹é‡é‡æ–°æˆæƒåŠŸèƒ½`,
                        'info',
                        10000 // 10ç§’æ˜¾ç¤ºæ—¶é—´
                    );
                }
            }

            // æ‰¹é‡é‡æ–°æˆæƒ
            async batchReauthorize() {
                const failedAccounts = this.accounts.filter(acc =>
                    acc.status === 'reauth_required' ||
                    acc.status === 'expired_refresh_token' ||
                    acc.status === 'invalid_refresh_token'
                );

                if (failedAccounts.length === 0) {
                    this.showNotification('æ²¡æœ‰éœ€è¦é‡æ–°æˆæƒçš„è´¦æˆ·', 'info');
                    return;
                }

                console.log(`[æ‰¹é‡é‡æ–°æˆæƒ] å¼€å§‹å¤„ç† ${failedAccounts.length} ä¸ªè´¦æˆ·`);
                this.showNotification(`æ­£åœ¨ä¸º ${failedAccounts.length} ä¸ªè´¦æˆ·ç”Ÿæˆé‡æ–°æˆæƒé“¾æ¥...`, 'info');

                await this.handleReauthorization(failedAccounts.map(acc => ({
                    account_id: acc.id,
                    email: acc.email,
                    status: acc.status,
                    message: acc.error || 'éœ€è¦é‡æ–°æˆæƒ'
                })));

                await this.saveAccounts();
                this.render();

                this.showNotification(`å·²ç”Ÿæˆ ${failedAccounts.length} ä¸ªé‡æ–°æˆæƒé“¾æ¥ï¼Œè¯·ç‚¹å‡»å¯¹åº”è´¦æˆ·çš„"é‡æ–°æˆæƒ"æŒ‰é’®`, 'success');
            }

            sendImportProgress(processed, total, currentEmail) {
                if (this.eventSource && this.sseConnected) {
                    fetch('/api/events/trigger', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            sessionId: this.sessionId,
                            type: 'import_progress',
                            processed: processed,
                            total: total,
                            current: currentEmail,
                            message: `å·²å¤„ç† ${processed}/${total} ä¸ªè´¦æˆ·`
                        })
                    }).catch(() => {});
                }
            }

            updateAccountStatus(accountId, status) {
                const account = this.accounts.find(acc => acc.id === accountId);
                if (account) {
                    account.status = status;
                    account.last_updated = new Date().toISOString();
                    this.saveAccounts();
                    this.render();
                    this.updateStats();
                }
            }

            // å¤„ç†OAuthå›è°ƒ
            async handleOAuthCallback() {
                console.log('[OAuthå›è°ƒ] å¤„ç†æˆæƒå›è°ƒ...');

                try {
                    const urlParams = new URLSearchParams(window.location.search);
                    const code = urlParams.get('code');
                    const state = urlParams.get('state');
                    const error = urlParams.get('error');

                    if (error) {
                        console.error('[OAuthå›è°ƒ] æˆæƒå¤±è´¥:', error);
                        this.showNotification(`æˆæƒå¤±è´¥: ${error}`, 'error');
                        this.clearOAuthCallbackParams();
                        return;
                    }

                    if (!code || !state) {
                        console.error('[OAuthå›è°ƒ] ç¼ºå°‘å¿…è¦å‚æ•°');
                        this.showNotification('æˆæƒå›è°ƒç¼ºå°‘å¿…è¦å‚æ•°', 'error');
                        this.clearOAuthCallbackParams();
                        return;
                    }

                    console.log('[OAuthå›è°ƒ] è·å–åˆ°æˆæƒç ï¼Œå¼€å§‹å…‘æ¢Token...');

                    // è§£æstateå‚æ•°è·å–è´¦æˆ·ä¿¡æ¯
                    let accountData;
                    try {
                        accountData = JSON.parse(atob(state));
                        console.log('[OAuthå›è°ƒ] è§£æè´¦æˆ·ä¿¡æ¯:', accountData);
                    } catch (e) {
                        console.error('[OAuthå›è°ƒ] æ— æ³•è§£æstateå‚æ•°:', e);
                        this.showNotification('æˆæƒå›è°ƒå‚æ•°è§£æå¤±è´¥', 'error');
                        this.clearOAuthCallbackParams();
                        return;
                    }

                    // è°ƒç”¨åç«¯APIå…‘æ¢Tokenå¹¶æ›´æ–°è´¦æˆ·
                    const response = await fetch('/api/auth/callback', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            code: code,
                            account_id: accountData.account_id,
                            email: accountData.email
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || `HTTP ${response.status}`);
                    }

                    const result = await response.json();
                    console.log('[OAuthå›è°ƒ] Tokenå…‘æ¢æˆåŠŸ:', result);

                    // æ›´æ–°è´¦æˆ·Tokenä¿¡æ¯
                    await this.updateAccountToken(accountData.account_id, result);

                    // æ¸…ç†URLå‚æ•°
                    this.clearOAuthCallbackParams();

                    this.showNotification(`è´¦æˆ· ${accountData.email} é‡æ–°æˆæƒæˆåŠŸï¼`, 'success');

                    // è‡ªåŠ¨ç»§ç»­é‚®ä»¶éªŒè¯æµç¨‹
                    console.log(`[OAuthå›è°ƒ] è´¦æˆ· ${accountData.email} é‡æ–°æˆæƒæˆåŠŸï¼Œè‡ªåŠ¨ç»§ç»­é‚®ä»¶éªŒè¯`);
                    setTimeout(() => {
                        this.continueValidationAfterReauth(accountData.account_id);
                    }, 1000);

                } catch (error) {
                    console.error('[OAuthå›è°ƒ] å¤„ç†å¤±è´¥:', error);
                    this.showNotification(`æˆæƒå›è°ƒå¤„ç†å¤±è´¥: ${error.message}`, 'error');
                    this.clearOAuthCallbackParams();
                }
            }

            // æ›´æ–°è´¦æˆ·Token
            async updateAccountToken(accountId, tokenData) {
                console.log(`[Tokenæ›´æ–°] æ›´æ–°è´¦æˆ· ${accountId} çš„Tokenä¿¡æ¯`);

                const account = this.accounts.find(acc => acc.id === accountId);
                if (!account) {
                    console.error(`[Tokenæ›´æ–°] æ‰¾ä¸åˆ°è´¦æˆ· ${accountId}`);
                    return false;
                }

                try {
                    // æ›´æ–°è´¦æˆ·ä¿¡æ¯
                    account.refresh_token = tokenData.refresh_token;
                    account.access_token = tokenData.access_token;
                    account.token_expires_at = tokenData.expires_at;
                    account.status = 'authorized';
                    account.reauth_required = false;
                    account.reauth_url = null;
                    account.error = null;
                    account.last_updated = new Date().toISOString();

                    console.log(`[Tokenæ›´æ–°] è´¦æˆ· ${account.email} Tokenæ›´æ–°æˆåŠŸ`);

                    // ä¿å­˜å¹¶åˆ·æ–°UI
                    await this.saveAccounts();
                    this.render();
                    this.updateStats();

                    return true;
                } catch (error) {
                    console.error(`[Tokenæ›´æ–°] æ›´æ–°è´¦æˆ· ${account.email} Tokenå¤±è´¥:`, error);
                    return false;
                }
            }

            // å¤„ç†é‡æ–°æˆæƒæŒ‰é’®ç‚¹å‡»
            async handleReauthorizationClick(accountId) {
                console.log(`[é‡æ–°æˆæƒ] ç”¨æˆ·ç‚¹å‡»é‡æ–°æˆæƒæŒ‰é’®: ${accountId}`);

                const account = this.accounts.find(acc => acc.id === accountId);
                if (!account) {
                    console.error(`[é‡æ–°æˆæƒ] æ‰¾ä¸åˆ°è´¦æˆ· ${accountId}`);
                    return;
                }

                if (!account.reauth_url) {
                    console.error(`[é‡æ–°æˆæƒ] è´¦æˆ· ${account.email} æ²¡æœ‰é‡æ–°æˆæƒURL`);
                    this.showNotification('è¯·å…ˆç”Ÿæˆé‡æ–°æˆæƒé“¾æ¥', 'error');
                    return;
                }

                try {
                    // æ„å»ºstateå‚æ•°
                    const stateData = {
                        account_id: account.id,
                        email: account.email,
                        timestamp: Date.now()
                    };
                    const state = btoa(JSON.stringify(stateData));

                    // æ„å»ºå®Œæ•´çš„OAuth URL
                    const oauthUrl = account.reauth_url.replace(/&state=[^&]*/, `&state=${state}`);

                    console.log(`[é‡æ–°æˆæƒ] æ‰“å¼€æˆæƒçª—å£: ${account.email}`);

                    // æ‰“å¼€æˆæƒçª—å£
                    const popup = window.open(
                        oauthUrl,
                        'oauth_popup',
                        'width=800,height=600,scrollbars=yes,resizable=yes'
                    );

                    // ç›‘å¬çª—å£å…³é—­
                    const checkClosed = setInterval(() => {
                        if (popup.closed) {
                            clearInterval(checkClosed);
                            console.log('[é‡æ–°æˆæƒ] æˆæƒçª—å£å·²å…³é—­');

                            // å»¶è¿Ÿæ£€æŸ¥å›è°ƒç»“æœ
                            setTimeout(() => {
                                this.handleOAuthCallback();
                            }, 1000);
                        }
                    }, 1000);

                    this.showNotification(`æ­£åœ¨ä¸ºè´¦æˆ· ${account.email} æ‰“å¼€é‡æ–°æˆæƒçª—å£...`, 'info');

                } catch (error) {
                    console.error(`[é‡æ–°æˆæƒ] æ‰“å¼€æˆæƒçª—å£å¤±è´¥:`, error);
                    this.showNotification(`æ‰“å¼€æˆæƒçª—å£å¤±è´¥: ${error.message}`, 'error');
                }
            }

            // æ¸…ç†OAuthå›è°ƒå‚æ•°
            clearOAuthCallbackParams() {
                const url = new URL(window.location);
                url.searchParams.delete('code');
                url.searchParams.delete('state');
                url.searchParams.delete('error');
                url.searchParams.delete('session_state');

                // æ›´æ–°URLä½†ä¸åˆ·æ–°é¡µé¢
                window.history.replaceState({}, document.title, url.pathname);
                console.log('[OAuthå›è°ƒ] å·²æ¸…ç†URLå‚æ•°');
            }
        }

        // å…¨å±€å®ä¾‹
        let manager;

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            manager = new SimpleMailManager();

            // æ£€æŸ¥æ˜¯å¦ä¸ºOAuthå›è°ƒ
            setTimeout(() => {
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has('code') || urlParams.has('error')) {
                    console.log('[åˆå§‹åŒ–] æ£€æµ‹åˆ°OAuthå›è°ƒï¼Œå¼€å§‹å¤„ç†...');
                    manager.handleOAuthCallback();
                }
            }, 500); // å»¶è¿Ÿ500msç¡®ä¿ç®¡ç†å™¨å®Œå…¨åˆå§‹åŒ–
        });

        // æ‰¹é‡å¯¼å…¥ç›¸å…³å‡½æ•°
        function showImportModal() {
            document.getElementById('importModal').classList.remove('hidden');
            document.getElementById('importTextarea').focus();
        }

        function hideImportModal() {
            document.getElementById('importModal').classList.add('hidden');
            document.getElementById('importTextarea').value = '';
        }

        function showProgressModal() {
            // é‡ç½®çŠ¶æ€ä¸ºå¯¼å…¥ä¸­
            document.getElementById('importingStatus').classList.remove('hidden');
            document.getElementById('importCompleteStatus').classList.add('hidden');
            document.getElementById('importCloseButton').classList.add('hidden');
            document.getElementById('importProgressModal').classList.remove('hidden');
        }

        function hideProgressModal() {
            document.getElementById('importProgressModal').classList.add('hidden');
        }

        function closeImportProgressModal() {
            hideProgressModal();
            // åˆ·æ–°ç•Œé¢æ˜¾ç¤ºå¯¼å…¥çš„è´¦æˆ·
            manager.filteredAccounts = [...manager.accounts];
            manager.render();
            manager.updateStats();
        }

        function showImportComplete(successCount, errorCount) {
            // æ˜¾ç¤ºå®ŒæˆçŠ¶æ€
            document.getElementById('importingStatus').classList.add('hidden');
            document.getElementById('importCompleteStatus').classList.remove('hidden');
            document.getElementById('importCloseButton').classList.remove('hidden');

            // è®¾ç½®ç»“æœæ–‡æœ¬
            const resultText = `æˆåŠŸ: ${successCount} ä¸ª\nå¤±è´¥: ${errorCount} ä¸ª`;
            document.getElementById('importResultText').textContent = resultText;
        }

        function showDetailedImportComplete(importedCount, totalCount, authorizedCount, reauthCount, errorCount) {
            // æ˜¾ç¤ºå®ŒæˆçŠ¶æ€
            document.getElementById('importingStatus').classList.add('hidden');
            document.getElementById('importCompleteStatus').classList.remove('hidden');
            document.getElementById('importCloseButton').classList.remove('hidden');

            // æ„å»ºè¯¦ç»†ç»“æœæ–‡æœ¬
            let resultText = `å¯¼å…¥å®Œæˆ: ${importedCount} ä¸ª\n\n`;
            resultText += `âœ… å®Œå…¨å°±ç»ª: ${authorizedCount} ä¸ª\n`;
            if (reauthCount > 0) {
                resultText += `âš ï¸ éœ€é‡æ–°æˆæƒ: ${reauthCount} ä¸ª\n`;
            }
            if (errorCount > 0) {
                resultText += `âŒ å¤„ç†å¤±è´¥: ${errorCount} ä¸ª\n`;
            }

            // æ·»åŠ éªŒè¯ç ç»Ÿè®¡
            const totalCodes = manager.accounts.reduce((sum, acc) => sum + (acc.codes?.length || 0), 0);
            if (totalCodes > 0) {
                resultText += `\nğŸ“§ å‘ç°éªŒè¯ç : ${totalCodes} ä¸ª`;
            }

            document.getElementById('importResultText').textContent = resultText;
            document.getElementById('importResultText').style.whiteSpace = 'pre-line';
        }

        function updateProgress(current, total, message) {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const progressCount = document.getElementById('progressCount');

            const percentage = Math.round((current / total) * 100);
            progressBar.style.width = percentage + '%';
            progressText.textContent = message;
            progressCount.textContent = `${current}/${total}`;
        }

        // æ™ºèƒ½è§£æå•è¡Œå¯¼å…¥æ•°æ®ï¼ˆä¸åŸç³»ç»Ÿç›¸åŒçš„é€»è¾‘ï¼‰
        function parseImportLine(line) {
            console.log(`[Parse Debug] è§£æè¡Œ:`, line);

            // é¢„å¤„ç†ï¼šç§»é™¤è¡Œé¦–è¡Œå°¾ç©ºç™½
            line = line.trim();
            if (!line) {
                console.warn(`[Parse] ç©ºè¡Œï¼Œè·³è¿‡`);
                return null;
            }

            // æ™ºèƒ½è§£æï¼šå…ˆæŒ‰----åˆ†å‰²ï¼Œå¦‚æœä¸æ˜¯4ä¸ªå­—æ®µï¼Œå†æŒ‰è¿ç»­çš„-åˆ†å‰²
            let parts = line.split('----');
            console.log(`[Parse Debug] ç¬¬ä¸€æ¬¡åˆ†å‰²ç»“æœ:`, parts, `å­—æ®µæ•°: ${parts.length}`);

            if (parts.length !== 4) {
                // å¦‚æœä¸æ˜¯4ä¸ªå­—æ®µï¼Œå°è¯•æ™ºèƒ½é‡æ„
                const uuidRegex = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i;
                const uuidMatch = line.match(uuidRegex);
                console.log(`[Parse Debug] UUIDåŒ¹é…ç»“æœ:`, uuidMatch);

                if (uuidMatch) {
                    const uuidIndex = line.indexOf(uuidMatch[0]);
                    const beforeUuid = line.substring(0, uuidIndex).trim();
                    const afterUuid = line.substring(uuidIndex + uuidMatch[0].length).trim();

                    const beforeParts = beforeUuid.split(/-+/);
                    if (beforeParts.length >= 2) {
                        parts = [
                            beforeParts[0],
                            beforeParts[1],
                            uuidMatch[0],
                            afterUuid.replace(/^-+/, '')
                        ];
                        console.log(`[Parse Debug] æ™ºèƒ½é‡æ„ç»“æœ:`, parts);
                    }
                }
            }

            if (parts.length < 4) {
                console.warn(`[Parse] æ— æ•ˆæ•°æ®æ ¼å¼ï¼ŒæœŸæœ›4ä¸ªå­—æ®µï¼Œå®é™…${parts.length}ä¸ª:`, line);
                console.warn(`[Parse] å­—æ®µè¯¦æƒ…:`, parts.map((p, i) => `å­—æ®µ${i+1}: "${p}"`));
                return null;
            }

            const [email, password, client_id, refresh_token_enc] = parts;

            // éªŒè¯æ¯ä¸ªå­—æ®µ
            if (!email || !email.includes('@')) {
                console.warn(`[Parse] æ— æ•ˆçš„é‚®ç®±åœ°å€: "${email}"`);
                return null;
            }

            if (!client_id || client_id.length < 10) {
                console.warn(`[Parse] æ— æ•ˆçš„client_id: "${client_id}"`);
                return null;
            }

            if (!refresh_token_enc || refresh_token_enc.length < 10) {
                console.warn(`[Parse] æ— æ•ˆçš„refresh_token: "${refresh_token_enc?.substring(0, 20)}..."`);
                return null;
            }

            const result = {
                email: email.trim(),
                password: password ? password.trim() : '',
                client_id: client_id.trim(),
                refresh_token: refresh_token_enc.trim()
            };

            console.log(`[Parse Debug] æœ€ç»ˆè§£æç»“æœ:`, {
                email: result.email,
                hasClientId: !!result.client_id,
                clientIdLength: result.client_id.length,
                hasRefreshToken: !!result.refresh_token,
                refreshTokenLength: result.refresh_token.length
            });

            return result;
        }

        // è§£æå¯¼å…¥æ•°æ®
        function parseImportData(importData) {
            const emails = [];
            const lines = importData.split('\n').filter(line => line.trim());

            for (const line of lines) {
                try {
                    const emailData = parseImportLine(line.trim());
                    if (emailData) {
                        emails.push(emailData);
                    }
                } catch (error) {
                    console.warn(`[Parse] è·³è¿‡æ— æ•ˆè¡Œ: ${line}`, error.message);
                }
            }

            return emails;
        }

        // å®Œæ•´çš„è´¦æˆ·å¤„ç†æµç¨‹ï¼ˆå¯¼å…¥åè‡ªåŠ¨æ‰§è¡Œï¼‰
        async function processAccountEmails(accountId) {
            const account = manager.accounts.find(acc => acc.id === accountId);
            if (!account) return;

            try {
                console.log(`[Process] å¼€å§‹å¤„ç†è´¦æˆ·: ${account.email}`);

                // 1. ç¡®ä¿æœ‰æœ‰æ•ˆçš„access_tokenï¼Œå¦‚æœæ²¡æœ‰åˆ™å°è¯•åˆ·æ–°
                if (!account.access_token) {
                    console.log(`[Process] è´¦æˆ·ç¼ºå°‘access_tokenï¼Œå°è¯•åˆ·æ–°token...`);
                    try {
                        await manager.validateAccountAuth(accountId);
                        console.log(`[Process] Tokenåˆ·æ–°æˆåŠŸ`);
                    } catch (tokenError) {
                        console.warn(`[Process] Tokenåˆ·æ–°å¤±è´¥ï¼Œä½†ä»å°è¯•åŒæ­¥é‚®ä»¶:`, tokenError);
                    }
                }

                // 2. åŒæ­¥é‚®ä»¶ï¼ˆå³ä½¿æ²¡æœ‰æœ‰æ•ˆtokenä¹Ÿå°è¯•ï¼‰
                await manager.syncAccountEmails(accountId);

                // 3. æ ¹æ®æ˜¯å¦æœ‰æœ‰æ•ˆtokenæ›´æ–°çŠ¶æ€
                if (account.access_token) {
                    manager.updateAccountStatus(accountId, 'authorized');
                    console.log(`[Process] è´¦æˆ·å¤„ç†å®Œæˆ: ${account.email} (çŠ¶æ€: authorized)`);
                } else {
                    manager.updateAccountStatus(accountId, 'reauth_needed');
                    console.log(`[Process] è´¦æˆ·å¤„ç†å®Œæˆ: ${account.email} (çŠ¶æ€: reauth_needed)`);
                }

            } catch (error) {
                console.error(`[Process] è´¦æˆ·å¤„ç†å¤±è´¥: ${account.email}`, error);
                manager.updateAccountStatus(accountId, 'error');
            }
        }

        // æ‰¹é‡å¯¼å…¥é‚®ç®±
        async function importEmails() {
            const textarea = document.getElementById('importTextarea');
            const content = textarea.value.trim();

            if (!content) {
                // æ˜¾ç¤ºæç¤ºçŠ¶æ€
                document.getElementById('importingStatus').classList.add('hidden');
                document.getElementById('importCompleteStatus').classList.remove('hidden');
                document.getElementById('importCloseButton').classList.remove('hidden');

                // è®¾ç½®æç¤ºç»“æœæ–‡æœ¬
                document.getElementById('importResultText').textContent = 'è¯·è¾“å…¥é‚®ç®±ä¿¡æ¯';

                // æ›´æ”¹å›¾æ ‡ä¸ºä¿¡æ¯çŠ¶æ€
                const statusIcon = document.querySelector('#importCompleteStatus .fa-check');
                if (statusIcon) {
                    statusIcon.classList.remove('fa-check', 'text-green-500');
                    statusIcon.classList.add('fa-info-circle', 'text-blue-500');
                }

                showProgressModal();
                return;
            }

            // éšè—å¯¼å…¥å¼¹çª—ï¼Œæ˜¾ç¤ºè¿›åº¦å¼¹çª—
            hideImportModal();
            showProgressModal();

            try {
                // ä½¿ç”¨ä¸åŸç³»ç»Ÿç›¸åŒçš„è§£æé€»è¾‘
                const emailData = parseImportData(content);

                if (emailData.length === 0) {
                    // æ˜¾ç¤ºæ— æ•°æ®çŠ¶æ€
                    document.getElementById('importingStatus').classList.add('hidden');
                    document.getElementById('importCompleteStatus').classList.remove('hidden');
                    document.getElementById('importCloseButton').classList.remove('hidden');

                    // è®¾ç½®æ— æ•°æ®ç»“æœæ–‡æœ¬
                    document.getElementById('importResultText').textContent = 'æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„é‚®ç®±ä¿¡æ¯';

                    // æ›´æ”¹å›¾æ ‡ä¸ºè­¦å‘ŠçŠ¶æ€
                    const statusIcon = document.querySelector('#importCompleteStatus .fa-check');
                    if (statusIcon) {
                        statusIcon.classList.remove('fa-check', 'text-green-500');
                        statusIcon.classList.add('fa-exclamation-triangle', 'text-yellow-500');
                    }
                    return;
                }

                console.log(`[å¯¼å…¥] è§£ææˆåŠŸï¼Œå…± ${emailData.length} ä¸ªé‚®ç®±`);
                updateProgress(0, emailData.length, 'æ­£åœ¨æ‰¹é‡å¯¼å…¥é‚®ç®±...');

                let successCount = 0;
                let errorCount = 0;

                for (let i = 0; i < emailData.length; i++) {
                    const data = emailData[i];

                    try {
                        // æ£€æŸ¥é‡å¤
                        if (manager.accounts.some(acc => acc.email === data.email)) {
                            console.log(`é‚®ç®± ${data.email} å·²å­˜åœ¨ï¼Œè·³è¿‡`);
                            updateProgress(i + 1, emailData.length, `é‚®ç®± ${data.email} å·²å­˜åœ¨ï¼Œè·³è¿‡`);
                            continue;
                        }

                        // è°ƒè¯•è¾“å‡ºè§£æç»“æœ
                        console.log(`[Debug] è§£æåˆ°çš„æ•°æ®:`, {
                            email: data.email,
                            hasClientId: !!data.client_id,
                            clientIdLength: data.client_id ? data.client_id.length : 0,
                            hasRefreshToken: !!data.refresh_token,
                            refreshTokenLength: data.refresh_token ? data.refresh_token.length : 0
                        });

                        // æ·»åŠ è´¦æˆ· - ç«‹å³ä¿ï¿½ï¿½ä¸ºpendingçŠ¶æ€
                        const account = await manager.addAccount(data.email, data.email, data.client_id, data.refresh_token);
                        console.log(`[å¯¼å…¥] è´¦æˆ· ${data.email} å·²ä¿å­˜ï¼ŒçŠ¶æ€: pending`);
                        successCount++;
                        updateProgress(i + 1, emailData.length, `â³ å·²ä¿å­˜: ${data.email}`);

  
                    } catch (error) {
                        console.error(`å¯¼å…¥ ${data.email} å¤±è´¥:`, error);
                        errorCount++;
                        updateProgress(i + 1, emailData.length, `å¯¼å…¥å¤±è´¥: ${data.email}`);
                    }
                }

                // å¯åŠ¨å¼‚æ­¥éªŒè¯ï¼ˆåå°å¤„ç†ï¼‰
                setTimeout(() => {
                    manager.startAsyncImportValidation();
                }, 1000);

                // æ˜¾ç¤ºå¯¼å…¥å®ŒæˆçŠ¶æ€
                setTimeout(() => {
                    showDetailedImportComplete(successCount, manager.accounts.length, 0, 0, 0);
                }, 500);

            } catch (error) {
                console.error('æ‰¹é‡å¯¼å…¥å¤±è´¥:', error);
                // æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
                document.getElementById('importingStatus').classList.add('hidden');
                document.getElementById('importCompleteStatus').classList.remove('hidden');
                document.getElementById('importCloseButton').classList.remove('hidden');

                // è®¾ç½®é”™è¯¯ç»“æœæ–‡æœ¬
                const resultText = `å¯¼å…¥å¤±è´¥: ${error.message}`;
                document.getElementById('importResultText').textContent = resultText;

                // æ›´æ”¹å›¾æ ‡ä¸ºé”™è¯¯çŠ¶æ€
                const statusIcon = document.querySelector('#importCompleteStatus .fa-check');
                if (statusIcon) {
                    statusIcon.classList.remove('fa-check', 'text-green-500');
                    statusIcon.classList.add('fa-exclamation-triangle', 'text-red-500');
                }
            }
        }

        function deleteAccountConfirm(id) {
            const account = manager.accounts.find(acc => acc.id === id);
            if (!account) return;

            if (confirm(`ç¡®å®šè¦åˆ é™¤é‚®ç®± "${account.name}" å—ï¼Ÿ\n\næ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
                manager.deleteAccount(id);
                manager.filteredAccounts = [...manager.accounts];
                manager.render();
                manager.updateStats();
            }
        }

        function syncAccount(id) {
            const account = manager.accounts.find(acc => acc.id === id);
            if (!account) return;

            if (account.status !== 'authorized') {
                // å¦‚æœæœªæˆæƒï¼Œå°è¯•ç›´æ¥éªŒè¯æˆæƒ
                manager.validateAccountAuth(id);
                return;
            }

            // çœŸå®åŒæ­¥è¿‡ç¨‹
            manager.syncAccountEmails(id);
        }

        // æ‰‹åŠ¨æ”¶å–é‚®ä»¶å‡½æ•°
        async function manualFetchEmails(id) {
            const account = manager.accounts.find(acc => acc.id === id);
            if (!account) {
                manager.showError('è´¦æˆ·ä¸å­˜åœ¨');
                return;
            }

            console.log('[æ‰‹åŠ¨å–ä»¶] æ‰¾åˆ°è´¦æˆ·:', account);
            console.log('[æ‰‹åŠ¨å–ä»¶] è´¦æˆ·é‚®ç®±:', account.email);
            console.log('[æ‰‹åŠ¨å–ä»¶] è´¦æˆ·ID:', id);
            console.log('[æ‰‹åŠ¨å–ä»¶] sessionId:', manager.sessionId);

            // æ˜¾ç¤ºå¼€å§‹é€šçŸ¥
            manager.showNotification(`æ­£åœ¨æ”¶å– ${account.email} çš„æœ€æ–°é‚®ä»¶...`, 'info');

            try {
                // ç¡®ä¿sessionIdå­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™ç”Ÿæˆä¸€ä¸ªæ–°çš„
                if (!manager.sessionId) {
                    const savedSessionId = localStorage.getItem('mail_manager_session_id');
                    if (savedSessionId) {
                        manager.sessionId = savedSessionId;
                        console.log('[æ‰‹åŠ¨å–ä»¶] æ¢å¤sessionId:', manager.sessionId);
                    } else {
                        manager.sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        localStorage.setItem('mail_manager_session_id', manager.sessionId);
                        console.log('[æ‰‹åŠ¨å–ä»¶] ç”Ÿæˆå¹¶ä¿å­˜æ–°sessionId:', manager.sessionId);
                    }
                }

                const requestData = {
                    account_id: id,
                    email: account.email,
                    client_id: account.client_id,
                    refresh_token: account.refresh_token,
                    access_token: account.access_token,
                    current_status: account.status,
                    session_id: manager.sessionId
                };

                console.log('[æ‰‹åŠ¨å–ä»¶] å‘é€çš„æ•°æ®:', requestData);
                console.log('[æ‰‹åŠ¨å–ä»¶] sessionIdç±»å‹å’Œé•¿åº¦:', typeof manager.sessionId, manager.sessionId.length);

                const response = await fetch('/api/manual-fetch-emails', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.details || result.message || 'æ”¶å–å¤±è´¥');
                }

                manager.showSuccess(`å·²å¯åŠ¨ ${account.email} çš„é‚®ä»¶æ”¶å–ï¼Œè¯·ç¨å€™...`);

            } catch (error) {
                console.error('æ‰‹åŠ¨å–ä»¶å¤±è´¥:', error);
                manager.showError(`æ‰‹åŠ¨å–ä»¶å¤±è´¥: ${error.message}`);
            }
        }

        function filterAccounts() {
            const searchQuery = document.getElementById('searchInput').value.trim();
            const statusFilter = document.getElementById('statusFilter').value;

            manager.filteredAccounts = manager.accounts.filter(account => {
                const matchesSearch = !searchQuery ||
                    account.email.toLowerCase().includes(searchQuery.toLowerCase()) ||
                    account.name.toLowerCase().includes(searchQuery.toLowerCase());

                const matchesStatus = !statusFilter || account.status === statusFilter;

                return matchesSearch && matchesStatus;
            });

            manager.render();
        }

        // åˆ·æ–°çŠ¶æ€ç®¡ç†
        let isRefreshing = false;

        async function refreshData() {
            // é˜²æ­¢é‡å¤åˆ·æ–°
            if (isRefreshing) {
                manager.showNotification('æ­£åœ¨åˆ·æ–°ä¸­ï¼Œè¯·ç¨å€™...', 'warning');
                return;
            }

            isRefreshing = true;
            const refreshButton = document.querySelector('button[onclick="refreshData()"]');
            const originalContent = refreshButton.innerHTML;

            try {
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                refreshButton.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i>åˆ·æ–°ä¸­...';
                refreshButton.disabled = true;
                refreshButton.classList.add('opacity-75', 'cursor-not-allowed');

                // æ˜¾ç¤ºåˆ·æ–°å¼€å§‹é€šçŸ¥
                manager.showNotification('æ­£åœ¨é‡æ–°åŠ è½½æ•°æ®...', 'info');
                console.log('[Refresh] å¼€å§‹é‡æ–°åŠ è½½æ•°æ®...');

                // 1. é‡æ–°ä»LocalStorageåŠ è½½è´¦æˆ·æ•°æ®
                console.log('[Refresh] é‡æ–°åŠ è½½è´¦æˆ·æ•°æ®...');
                await manager.loadAccounts();

                // 2. é‡æ–°åˆå§‹åŒ–åºåˆ—å·ç®¡ç†å™¨
                console.log('[Refresh] é‡æ–°åˆå§‹åŒ–åºåˆ—å·ç®¡ç†å™¨...');
                await manager.sequenceManager.initialize(manager.accounts);

                // 3. æ–­å¼€å¹¶é‡æ–°è¿æ¥SSE
                console.log('[Refresh] é‡æ–°è¿æ¥SSEå®æ—¶æ›´æ–°...');
                if (manager.eventSource) {
                    manager.eventSource.close();
                    manager.eventSource = null;
                    manager.sseConnected = false;
                }
                manager.connectSSE();

                // 4. é‡æ–°æ¸²æŸ“ç•Œé¢å’Œæ›´æ–°ç»Ÿè®¡
                console.log('[Refresh] é‡æ–°æ¸²æŸ“ç•Œé¢...');
                manager.render();
                manager.updateStats();

                // 5. æ˜¾ç¤ºåˆ·æ–°å®Œæˆé€šçŸ¥
                const accountCount = manager.accounts.length;
                const message = accountCount > 0
                    ? `æ•°æ®é‡æ–°åŠ è½½å®Œæˆï¼å…± ${accountCount} ä¸ªè´¦æˆ·`
                    : 'æ•°æ®é‡æ–°åŠ è½½å®Œæˆï¼æš‚æ— è´¦æˆ·æ•°æ®';

                manager.showNotification(message, 'success');
                console.log('[Refresh] æ•°æ®é‡æ–°åŠ è½½å®Œæˆ');

            } catch (error) {
                console.error('[Refresh] æ•°æ®é‡æ–°åŠ è½½å¤±è´¥:', error);
                manager.showError('æ•°æ®é‡æ–°åŠ è½½å¤±è´¥: ' + error.message);

                // å³ä½¿å‡ºé”™ä¹Ÿå°è¯•é‡æ–°æ¸²æŸ“ç•Œé¢
                try {
                    manager.render();
                    manager.updateStats();
                } catch (renderError) {
                    console.error('[Refresh] ç•Œé¢é‡æ–°æ¸²æŸ“ä¹Ÿå¤±è´¥:', renderError);
                    manager.showError('æ•°æ®åŠ è½½å’Œç•Œé¢æ¸²æŸ“éƒ½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢');
                }
            } finally {
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                isRefreshing = false;
                refreshButton.innerHTML = originalContent;
                refreshButton.disabled = false;
                refreshButton.classList.remove('opacity-75', 'cursor-not-allowed');
            }
        }

        function confirmClearAllData() {
            if (manager.accounts.length === 0) {
                manager.showError('å½“å‰æ²¡æœ‰æ•°æ®éœ€è¦æ¸…ç©º');
                return;
            }

            // æ˜¾ç¤ºæ¸…ç©ºæ•°æ®ç¡®è®¤å¼¹çª—
            document.getElementById('clearDataModal').classList.remove('hidden');

            // é‡ç½®ç¡®è®¤å¤é€‰æ¡†çŠ¶æ€
            document.getElementById('confirmCheckbox').checked = false;
            document.getElementById('confirmClearButton').disabled = true;
        }

        function hideClearDataModal() {
            document.getElementById('clearDataModal').classList.add('hidden');
        }

        function clearAllData() {
            // æ¸…ç©ºæ‰€æœ‰æ•°æ®
            manager.accounts = [];
            manager.filteredAccounts = [];

            // æ¸…ç©ºæœ¬åœ°å­˜å‚¨
            localStorage.removeItem('mailmanager_accounts');

            // åˆ·æ–°ç•Œé¢
            manager.render();
            manager.updateStats();

            // å…³é—­å¼¹çª—å¹¶æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            hideClearDataModal();
            manager.showSuccess('æ‰€æœ‰æ•°æ®å·²æˆåŠŸæ¸…ç©ºï¼');
        }

        function toggleAccountSelection(accountId, isChecked) {
            const account = manager.accounts.find(acc => acc.id === accountId);
            if (account) {
                account.selected = isChecked;
                manager.saveAccounts();
            }
        }

        // æ’åºå‡½æ•°
        function sortBySequence() {
            manager.sortField = 'sequence';
            manager.sortDirection = manager.sortDirection === 'asc' ? 'desc' : 'asc';
            manager.render();
        }

        function sortByStatus() {
            manager.sortField = 'status';
            manager.sortDirection = manager.sortDirection === 'asc' ? 'desc' : 'asc';
            manager.render();
        }

        function sortByEmail() {
            manager.sortField = 'email';
            manager.sortDirection = manager.sortDirection === 'asc' ? 'desc' : 'asc';
            manager.render();
        }

        function sortByCodeTime() {
            manager.sortField = 'received_time';
            manager.sortDirection = manager.sortDirection === 'asc' ? 'desc' : 'asc';
            manager.render();
        }

        function sortBySender() {
            manager.sortField = 'sender';
            manager.sortDirection = manager.sortDirection === 'asc' ? 'desc' : 'asc';
            manager.render();
        }

        function changePageSize() {
            const pageSize = document.getElementById('pageSize').value;
            manager.changePageSize(pageSize);
        }

        function copyEmailToClipboard(accountId) {
            manager.copyEmailToClipboard(accountId);
        }

        function copyLatestCode(accountId) {
            manager.copyLatestCode(accountId);
        }

        function handleAccountSelection(checkbox) {
            const accountId = checkbox.dataset.accountId; // ä½¿ç”¨å­—ç¬¦ä¸²IDï¼Œä¸è½¬æ¢ä¸ºæ•°å­—
            if (checkbox.checked) {
                manager.selectedAccounts.add(accountId);
            } else {
                manager.selectedAccounts.delete(accountId);
            }
            console.log('å·²é€‰ä¸­çš„è´¦æˆ·:', Array.from(manager.selectedAccounts));
        }

        function changePage(delta) {
            manager.changePage(delta);
        }

        function goToPage(page) {
            manager.goToPage(page);
        }

        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        window.onclick = function(event) {
            const modal = document.getElementById('addModal');
            if (event.target === modal) {
                modal.classList.add('hidden');
            }
        }
    </script>
</body>
</html>